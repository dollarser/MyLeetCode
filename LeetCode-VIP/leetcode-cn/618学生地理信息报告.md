# 618学生地理信息报告
<p>表：&nbsp;<code>student</code>&nbsp;</p>

<pre>
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| name        | varchar |
| continent   | varchar |
+-------------+---------+
该表没有主键。它可能包含重复的行。
该表的每一行表示学生的名字和他们来自的大陆。
</pre>

<p>&nbsp;</p>

<p>一所学校有来自亚洲、欧洲和美洲的学生。</p>

<p>写一个查询语句实现对大洲（continent）列的&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%80%8F%E8%A7%86%E8%A1%A8" target="_blank">透视表</a> 操作，使得每个<code>学生</code>按照姓名的<strong>字母顺序</strong>依次排列在对应的大洲下面。输出的标题应依次为<code>美洲（America）、亚洲（Asia）和欧洲（Europe）。</code></p>

<p>测试用例的生成使得来自美国的学生人数不少于亚洲或欧洲的学生人数。</p>

<p>查询结果格式如下所示。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> 
Student table:
+--------+-----------+
| name   | continent |
+--------+-----------+
| Jane   | America   |
| Pascal | Europe    |
| Xi     | Asia      |
| Jack   | America   |
+--------+-----------+
<strong>输出:</strong> 
+---------+------+--------+
| America | Asia | Europe |
+---------+------+--------+
| Jack    | Xi   | Pascal |
| Jane    | null | null   |
+---------+------+--------+</pre>

<p>&nbsp;</p>

<p><strong>进阶：</strong>如果不能确定哪个大洲的学生数最多，你可以写出一个查询去生成上述学生报告吗？</p>
































# 解题:
# 1.学生地理信息报告
#### 方法：使用 "session 变量" 和 `join`【通过】

**思路**

为每个大洲分配一个单独的行自增 id，然后将它们连接。

**算法**

使用 session 变量为每个大洲分配单独的行自增 id。例如下面语句为美洲的学生分配行自增 id。

```mysql [snippet1-MySQL]
SELECT 
    row_id, America
FROM
    (SELECT @am:=0) t,
    (SELECT 
        @am:=@am + 1 AS row_id, name AS America
    FROM
        student
    WHERE
        continent = 'America'
    ORDER BY America) AS t2
;
```

```
| row_id | America |
|--------|---------|
| 1      | Jack    |
| 2      | Jane    |
```

同理，为其他大洲分配单独的行自增 id。

```
| row_id | Asia |
|--------|------|
| 1      | Xi   |
```

```
| row_id | Europe |
|--------|--------|
| 1      | Jesper |
```

然后使用相同的 `row_id` 将这 3 个临时表连接，得到下表。

```
| row_id | America | Asia | Europe |
|--------|---------|------|--------|
| 1      | Jack    | Xi   | Pascal |
| 2      | Jane    |      |        |
```

这里有一个问题，如果使用内连接，那么美洲的学生记录会显示不完整，所以应该使用外连接。另外也应该将美洲的学生表放在中间，然后使用 `right (outer) join` 和 `left (outer) join` 连接另外两张表。

**MySQL**

```mysql [solution1-MySQL]
SELECT 
    America, Asia, Europe
FROM
    (SELECT @as:=0, @am:=0, @eu:=0) t,
    (SELECT 
        @as:=@as + 1 AS asid, name AS Asia
    FROM
        student
    WHERE
        continent = 'Asia'
    ORDER BY Asia) AS t1
        RIGHT JOIN
    (SELECT 
        @am:=@am + 1 AS amid, name AS America
    FROM
        student
    WHERE
        continent = 'America'
    ORDER BY America) AS t2 ON asid = amid
        LEFT JOIN
    (SELECT 
        @eu:=@eu + 1 AS euid, name AS Europe
    FROM
        student
    WHERE
        continent = 'Europe'
    ORDER BY Europe) AS t3 ON amid = euid
;
```
# 2.总结各类表格格式化问题
表格格式化问题是我很懵逼的一个点之一，今天就总结一下表格题的套路，大家一起学习进步。
这里的题型我认为可以分为以下两种：
**1. 表格转换问题**
618.学生地理信息报告(困难);
1179.重新格式化部门表(简单);
1435.制作会话柱状图(简单);
1777.每家商店的产品价格(简单);
1795.Rearrange Product Table(简单)
**2. 设计序列构建新表格问题**
1127.用户购买平台(困难);
1336.每次访问的交易次数(困难);
1384.按年度列出销售总额(困难);
1613.找到遗失的ID(中等)
1635.Hopper公司查询I(困难);
1767.Find the subtasks that did not execute(困难)

首先，我们来说说表格转换问题，这类问题通常分为以下两点：
**1.1  行转列问题**
————————————————————————————————————
**通用解题技巧1:group by+sum/max/min(case when)**
**tips:原表格有基准id如product_id,department_id等。**
———————————————————————————————————
练习题：1777.每家商店的产品价格(简单);1179.重新格式化部门表(简单)。
这里以1777为例来讲解答题模板：
![image.png](https://pic.leetcode-cn.com/1616504234-kclgrh-image.png)
这里我们的需求是将products表转换为result的表，贴出我们的解题代码：
```
SELECT product_id,
       SUM(CASE store WHEN 'store1' THEN price ELSE NULL END) AS 'store1',
       SUM(CASE store WHEN 'store2' THEN price ELSE NULL END) AS 'store2',
       SUM(CASE store WHEN 'store3' THEN price ELSE NULL END) AS 'store3'
FROM products
GROUP BY product_id
```

***Caution1：为什么需要使用sum？***
这里牵扯到了使用group by后，系统留存的虚拟表格，如果我们不使用sum，则select中的语句是默认对group by后的两行进行操作，如下：
```
SELECT * FROM products GROUP BY product_id
```
![2.png](https://pic.leetcode-cn.com/1616501840-BkLKBy-2.png)
此时，若我们不使用聚合函数，对表格进行一个转换，得到的结果：
```
SELECT product_id,
       CASE store WHEN 'store1' THEN price END AS store1,
       CASE store WHEN 'store2' THEN price END AS store2,
       CASE store WHEN 'store3' THEN price END AS store3
FROM products
GROUP BY product_id
```
![image.png](https://pic.leetcode-cn.com/1616501918-iMQgcO-image.png)
因此系统默认我们只对group by筛选出的第一行进行判断而舍弃了剩下的数据行。
正确的做法是加上聚合函数sum:
```
SELECT product_id,
       SUM(CASE store WHEN 'store1' THEN price ELSE NULL END) AS 'store1',
       SUM(CASE store WHEN 'store2' THEN price ELSE NULL END) AS 'store2',
       SUM(CASE store WHEN 'store3' THEN price ELSE NULL END) AS 'store3'
FROM products
GROUP BY product_id
```
此外group by的本质也可以观看这篇教程：[https://leetcode-cn.com/problems/reformat-department-table/solution/group-byben-zhi-lun-by-loverxp-7mgy/](group by本质论)

———————————————————————————————————
**通用解题技巧2:row_number()+group by+max(if)**
**tips:原表格没有基准id需要自己构造。**
———————————————————————————————————
练习题：618.学生地理信息报告(困难)。
![image.png](https://pic.leetcode-cn.com/1616502405-gYQvKm-image.png)
![image.png](https://pic.leetcode-cn.com/1616502419-wgdTQb-image.png)
将样例转换为输出的难点主要在于：无法确定哪个大洲的学生数最多。（本次题解不讨论普适性较差的写法）
因此，我们需要在题中构造一个基准id，这样可以使题目适应解题技巧1的写法。
```
#step1.构造基准id，使用row_number()窗口函数
SELECT *, ROW_NUMBER() OVER (PARTITION BY continent ORDER BY NAME) rk FROM student
```
![image.png](https://pic.leetcode-cn.com/1616502694-SbotYS-image.png)
这样运行我们可以得到如上图所示的结果，那么题目就转换为第一种形式了。
```
#step2.解题技巧1：group by+sum/max/min(case when)

SELECT 
    MAX(CASE continent WHEN 'Asia'THEN NAME ELSE NULL END) AS Asia,
    MAX(CASE continent WHEN 'America'THEN NAME ELSE NULL END) AS America,
    MAX(CASE continent WHEN 'Europe'THEN NAME ELSE NULL END) AS Europe 
FROM 
    (SELECT *, ROW_NUMBER() OVER (PARTITION BY continent ORDER BY NAME) rk FROM student) t
GROUP BY rk;
```


本题未选择sum函数的原因在于，表格中输出的数据为文本数据，不能进行直接加减。
———————————————————————————————————
**总结**
- 观察题中是否有基准id,若题中无基准id，需要先使用row_number()进行构造
- 使用的聚合函数sum/max/min是根据列中的数据格式决定的


**1.2  列转行问题**
———————————————————————————————————
**通用解题技巧:union all**
———————————————————————————————————
练习题:1435.制作会话柱状图;1795 Rearrange Product Table
本次讲解以1435为例，首先是题目的需求：
![image.png](https://pic.leetcode-cn.com/1616504183-cySlnx-image.png)
我第一次看见这道题的result表格时，我人直接懵了，好家伙直接一个无中生有的列和列中的数据，这时我们该怎么解决这个问题？谜底就在谜面上，我们也要无中生有！
**需求分析**：
1.我们需要构造一个bin，bin中有[0-5>,[5-10>等字符串 ——> select '[0-5>' bin 硬写
2.得到session中的数据，这个很简单直接根据sessions表进行一个count计算，并在where中指定约束条件 ——> 如：select count(*) from sessions where WHERE duration BETWEEN 0 AND 5*60
3.将上述的多个表格进行一个union all 得到 一个虚拟表格包括不同约束条件下的值
因此，我们可以给出我们的代码:
```
SELECT '[0-5>' bin, COUNT(*) total
FROM Sessions
WHERE duration BETWEEN 0 AND 5*60
UNION ALL
SELECT '[5-10>' bin, COUNT(*) total
FROM Sessions
WHERE duration BETWEEN 5*60 AND 10*60
UNION ALL
SELECT '[10-15>' bin, COUNT(*) total
FROM Sessions
WHERE duration BETWEEN 10*60 AND 15*60
UNION ALL
SELECT '15 or more' bin, COUNT(*) total
FROM Sessions
WHERE duration >= 15*60
```




接下来进入我们的第二节：设计序列构建新表格问题，这类问题的核心要点在于**掌握递归查询**~
**2.1 设计序列构建新表格问题1：数列构建**
————————————————————————————————————
**通用解题技巧：with语句+left join**
**tips:result表中出现无中生有的列，且列中的数据为一个逐渐递增的数列，考虑使用with方法**
————————————————————————————————————
练习题：1336.每次访问的交易次数; 1635. Hopper 公司查询 I(全系列还包括II III);
       1613.找到遗失的ID; 1767. Find the Subtasks That Did Not Execute;（虽然不是表格问题，但仍旧用with解决的两个问题）
以**1336题为例**进行一个讲解：
![image.png](https://pic.leetcode-cn.com/1616553097-ywtyUK-image.png)
首先是一个**需求分析**：我们想要结合Visits,transactions表得到最后的结果表，从结果表的列来看我们需要总结两个属性：transactions_count,visits_count，其中：
**需求1**：transactions_count是客户在一次访问（一天）中进行的交易次数。result表中来看，交易次数是一个0到3的连续数列，如果我们仔细的分析transactions表，其实可以发现没有客户的交易次数为2。因此，如果我们想直接通过transactions表和visits表进行总结的话会缺少2这一行(即第3行),因此我们采用with递归查询构建数列。
**需求2**: visits_count是在transactions_count 交易次数下相应的一次访问时的客户数量，是可以通过visits表和transaction表进行一个统计的。因此我们如果有了前面已建立好的序列，再与我们最后的统计结果进行一个left join就可以得到最终的结果表。
```
#step1:构建数列
WITH RECURSIVE t(transactions_count) AS
(
SELECT 0
UNION ALL
SELECT transactions_count+1 FROM t WHERE transactions_count <(
		SELECT MAX(count_num) max_num
        FROM (
            SELECT COUNT(*) OVER (PARTITION BY transaction_date,user_id) count_num
            FROM transactions
        ) t
	)
)

SELECT * FROM t
```
这样我们就可以得到一下序列。
![image.png](https://pic.leetcode-cn.com/1616554231-nojiNJ-image.png)

```
#step2:统计visits_count
#分为两步：统计每个user_id在当天的交易次数，再对交易次数进行group求出每个交易次数对应的所有user_id
SELECT t.transactions_count,IFNULL(visits_count,0) visits_count
FROM t
LEFT JOIN (
    #不同的交易频次所对应的user_id个数
	SELECT t_num transations_count, COUNT(*) visits_count
	FROM(
		SELECT user_id, visit_date,COUNT(user_id2) t_num #每个user_id在某天的交易频次
		FROM(
			SELECT v.user_id,v.visit_date,t.user_id user_id2 FROM visits v LEFT JOIN transactions t
			ON v.visit_date = t.transaction_date AND v.user_id = t.user_id
		) t1
		GROUP BY user_id,visit_date
	) t2
	GROUP BY t_num
) t4 ON t.transactions_count = t4.transations_count
GROUP BY t.transactions_count

```
最后将我们的代码连接起来就完美的解决了这类问题~（以上代码并不能分段运行）。
```
WITH RECURSIVE t(transactions_count) AS
(
SELECT 0
UNION ALL
SELECT transactions_count+1 FROM t WHERE transactions_count <(
		SELECT MAX(count_num) max_num
        FROM (
            SELECT COUNT(*) OVER (PARTITION BY transaction_date,user_id) count_num
            FROM transactions
        ) t
	)
)

SELECT t.transactions_count,IFNULL(visits_count,0) visits_count
FROM t
LEFT JOIN (
	SELECT t_num transations_count, COUNT(*) visits_count
	FROM(
		SELECT user_id, visit_date,COUNT(user_id2) t_num
		FROM(
			SELECT v.user_id,v.visit_date,t.user_id user_id2 FROM visits v LEFT JOIN transactions t
			ON v.visit_date = t.transaction_date AND v.user_id = t.user_id
		) t1
		GROUP BY user_id,visit_date
	) t2
	GROUP BY t_num
) t4 ON t.transactions_count = t4.transations_count
GROUP BY t.transactions_count
```
**2.2 设计序列构建新表格问题2：字符串构建**
————————————————————————————————————
**通用解题技巧：union all+left join**
**tips:result表中出现无中生有的列，且列中的数据为未曾出现过的字符串，考虑使用union all方法**
————————————————————————————————————
练习题:1127.用户购买平台
以**1127题为例**进行一个讲解：
![image.png](https://pic.leetcode-cn.com/1616555271-HKKIwT-image.png)
**需求分析**
1.spending表中platform只有mobile和desktop两种，没有result中的both，因此我们需要自己构建一个both数据行(使用select 字符串 union select 字符串)。
2.total_amount需要从spending中的amount中分组求和
3.total_users考察用户是否正确的分入了both,mobile,desktop三种类型中，并分组计数 

**step1:构建新的字符串数据行**
```
SELECT *
FROM(
SELECT DISTINCT spend_date, 'desktop' AS platform FROM spending
UNION
SELECT DISTINCT spend_date, 'mobile' AS platform FROM spending
UNION
SELECT DISTINCT spend_date, 'both' AS platform FROM spending
) t1 
```
**step2:分组求和total_amount**
```
SELECT *,SUM(amount) OVER (PARTITION BY spend_date,user_id) total_amount FROM spending
```
**step3:查询每个用户在每个日期的平台类型**
```
SELECT spend_date, user_id,IF(COUNT(*)=1,platform,'both') AS platform FROM Spending GROUP BY spend_date, user_id
```
**step4:left join**

```
SELECT t2.spend_date, t2.platform, IFNULL(SUM(amount), 0) AS total_amount,
IFNULL(COUNT(DISTINCT user_id), 0) AS total_users
FROM
(   #1.构造所需的表
    SELECT DISTINCT spend_date, "desktop" AS platform FROM Spending
    UNION
    SELECT DISTINCT spend_date, "mobile" AS platform FROM Spending
    UNION
    SELECT DISTINCT spend_date, "both" AS platform FROM Spending    
) AS t2
LEFT JOIN 
(   #2.查询每个用户，每个日期，每个平台类型，总金额
    SELECT spend_date, user_id, SUM(amount) AS amount,
    IF(COUNT(*)=1,platform,'both') AS platform
    FROM Spending 
    GROUP BY spend_date, user_id
) AS t1
#3.左连接，并按日期和平台分组
ON t2.spend_date = t1.spend_date AND t2.platform = t1.platform
GROUP BY t2.spend_date, t2.platform
```
————————————————————————————————————
**总结**
- result表中出现 **自增长的未出现过的数列** 使用**with**方法构造数列
- result表中出现 **未出现的字符串列** 使用**union all**构造字符串列

# 3.【详解】学生地理信息报告（为什么分组排序后取max可以去掉null详解）
先来看看直观的想法，利用case when来进行分列操作，直接用以下代码：
```
select
case when continent = 'America' then name end as America,
case when continent = 'Asia' then name end as Asia,
case when continent = 'Europe' then name end as Europe
from student
```
将得到以下结果：
![image.png](https://pic.leetcode-cn.com/1660813372-wYOTHz-image.png)
可以看到有很多的null，为了去掉这些null,我们进行以下操作：
**第一步，先用row_number() over()进行分组排序：**
```
select
*,
row_number() over(partition by continent order by name) rn
from
student
```
得到如下结果：
![image.png](https://pic.leetcode-cn.com/1660813025-nqdFXU-image.png)

**第二步，利用case when进行行转列**
```
select
case when continent = 'America' then name end as America,
case when continent = 'Asia' then name end as Asia,
case when continent = 'Europe' then name end as Europe
from
(
select
*,
row_number() over(partition by continent order by name) rn
from
student
)a
```
进行以上代码操作，会产生4行数据，如下：
![image.png](https://pic.leetcode-cn.com/1660813047-nDEpoB-image.png)

可以看到有很多null，为了去掉过多的null，需进行第三步操作。
**第三步，按照rn进行分组，并对每组数据取max或者min**
这样做可以去掉多余的null，使得每一列下如果name非空就只保留name。
（补充：max和min在计算中时忽略null的，这里用max或者min是因为计算的是字符串类型，如果是数值型可以用sum）
```
select
max(case when continent = 'America' then name end) as America,
max(case when continent = 'Asia' then name end) as Asia,
max(case when continent = 'Europe' then name end) as Europe
from
(
select
*,
row_number() over(partition by continent order by name) rn
from
student
)a
group by rn
```
即可得到题目要求的结果。


# 4.三种方法分析（解题+进阶）——学生地理信息报告
## SQL：方法一

```sql
select America, Asia, Europe from (
	select
		name as America,
		row_number() over(order by name) as rn
	from student where continent = 'America'
) temp1 left join (
	select
		name as Europe,
		row_number() over(order by name) as rn
	from student where continent = 'Europe'
) temp2 on temp1.rn = temp2.rn left join (
	select
		name as Asia,
		row_number() over(order by name) as rn
	from student where continent = 'Asia'
) temp3 on temp1.rn = temp3.rn;
```

## 解析

对 `continent` 实现透视操作，就是说把 `continent` 的每一行变成列，再合并重复的列。

要实现透视操作， `continent` 每个值按照 `America` 、 `Europe` 、 `Asia` 进行分类并排序。

排序可以使用 `row_number()` 。

将 `America` 、 `Europe` 、 `Asia` 值作为临时表 `temp1` 、 `temp2` 、 `temp3` ，使用左连依次将这三个表连接，连接条件是各表的 `rn`

## SQL：方法二

```sql
select
	America, Asia, Europe
from (select @america:=0, @europe:=0, @asia:=0) as init, (
	select
		name as America,
		@america:= @america + 1 as america_id
	from student where continent = 'America' order by name
) t1 left join (
	select
		name as Europe,
		@europe:= @europe + 1 as europe_id
	from student where continent = 'Europe' order by name
) t2 on america_id = europe_id left join (
	select
		name as Asia,
		@asia:= @asia + 1 as asia_id
	from student where continent = 'Asia' order by name
) t3 on america_id = asia_id;
```

## 解析

方法二和方法一是一样的思路，这里的排序用的是变量。

## Tips

方法一和方法二都有一个问题：需要知道哪个大洲的人数最多，人数多的表作为基准表，别的表与它相连，也就是说表连接的方式是从大到小。

## SQL：方法三

```sql
select
	max(case continent when 'America' then name else null end) America,
	max(case continent when 'Asia' then name else null end) Aisa,
	max(case continent when 'Europe' then name else null end) Europe
from (
	select
		*,
		row_number() over(partition by continent order by name) as rn
	from student
) temp group by rn;
```

## 解析

方法三解决了需要先知道哪个大洲人数最多的问题。

使用 `row_number()` 按照 `continent` 分组并排序，序号为 `rn` ，作为临时表 `temp`

查询临时表 `temp` 按照 `rn` 分组

每一列使用 `case ... when ... then ... end` 查询出 `America`、 `Asia`、 `Europe` ，因为要使用到 `group by` ，所以需要使用到聚合函数， `max` 和 `min` 都可以。

更多解题：https://github.com/astak16/blog-mysql/issues/46
