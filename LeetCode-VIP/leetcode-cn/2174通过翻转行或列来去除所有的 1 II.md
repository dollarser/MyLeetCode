# 2174é€šè¿‡ç¿»è½¬è¡Œæˆ–åˆ—æ¥å»é™¤æ‰€æœ‰çš„ 1 II
<p>ç»™å®š&nbsp;<strong>ä¸‹æ ‡ä» 0 å¼€å§‹&nbsp;</strong>çš„ <code>m x n</code> <strong>äºŒè¿›åˆ¶&nbsp;</strong>çŸ©é˜µ <code>grid</code>ã€‚</p>

<p>åœ¨ä¸€æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥é€‰æ‹©æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„ä»»æ„ <code>i</code> å’Œ <code>j</code>:</p>

<ul>
	<li><code>0 &lt;= i &lt; m</code></li>
	<li><code>0 &lt;= j &lt; n</code></li>
	<li><code>grid[i][j] == 1</code></li>
</ul>

<p>å¹¶å°†ç¬¬ <code>i</code> è¡Œå’Œç¬¬ <code>j</code> åˆ—ä¸­çš„&nbsp;<strong>æ‰€æœ‰&nbsp;</strong>å•å…ƒæ ¼çš„å€¼æ›´æ”¹ä¸ºé›¶ã€‚</p>

<p>è¿”å›<em>ä»&nbsp;</em><code>grid</code><em> ä¸­åˆ é™¤æ‰€æœ‰ <code>1</code> æ‰€éœ€çš„æœ€å°æ“ä½œæ•°ã€‚</em></p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/02/13/image-20220213162716-1.png" style="width: 709px; height: 200px;" />
<pre>
<strong>è¾“å…¥:</strong> grid = [[1,1,1],[1,1,1],[0,1,0]]
<strong>è¾“å‡º:</strong> 2
<strong>è§£é‡Š:</strong>
åœ¨ç¬¬ä¸€ä¸ªæ“ä½œä¸­ï¼Œå°†ç¬¬ 1 è¡Œå’Œç¬¬ 1 åˆ—çš„æ‰€æœ‰å•å…ƒæ ¼å€¼æ›´æ”¹ä¸º 0ã€‚
åœ¨ç¬¬äºŒä¸ªæ“ä½œä¸­ï¼Œå°†ç¬¬ 0 è¡Œå’Œç¬¬ 0 åˆ—çš„æ‰€æœ‰å•å…ƒæ ¼å€¼æ›´æ”¹ä¸º 0ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/02/13/image-20220213162737-2.png" style="width: 734px; height: 200px;" />
<pre>
<strong>è¾“å…¥:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]
<strong>è¾“å‡º:</strong> 2
<strong>è§£é‡Š:</strong>
åœ¨ç¬¬ä¸€ä¸ªæ“ä½œä¸­ï¼Œå°†ç¬¬ 1 è¡Œå’Œç¬¬ 0 åˆ—çš„æ‰€æœ‰å•å…ƒæ ¼å€¼æ›´æ”¹ä¸º 0ã€‚
åœ¨ç¬¬äºŒä¸ªæ“ä½œä¸­ï¼Œå°†ç¬¬ 2 è¡Œå’Œç¬¬ 1 åˆ—çš„æ‰€æœ‰å•å…ƒæ ¼å€¼æ›´æ”¹ä¸º 0ã€‚
æ³¨æ„ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨è¡Œ 1 å’Œåˆ— 1 æ‰§è¡Œæ“ä½œï¼Œå› ä¸º grid[1][1]!= 1ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 3:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/02/13/image-20220213162752-3.png" style="width: 156px; height: 150px;" />
<pre>
<strong>è¾“å…¥:</strong> grid = [[0,0],[0,0]]
<strong>è¾“å‡º:</strong> 0
<strong>è§£é‡Š:</strong>
æ²¡æœ‰ 1 å¯ä»¥ç§»é™¤ï¼Œæ‰€ä»¥è¿”å›0ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤º:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 15</code></li>
	<li><code>1 &lt;= m * n &lt;= 15</code></li>
	<li><code>grid[i][j]</code> ä¸º&nbsp;<code>0</code>&nbsp;æˆ–&nbsp;<code>1</code>ã€‚</li>
</ul>
































# è§£é¢˜:
# 1.ã€daydayUpppğŸˆã€‘å­é›†æšä¸¾ + çŠ¶å‹DP
### è§£é¢˜æ€è·¯

1. $n * m <= 15$ å¯ä»¥è”æƒ³åˆ° **çŠ¶æ€å‹ç¼©** , æŠŠæ‰€æœ‰çš„ 1 çš„è¡¨ç¤ºä¸ºä¸€ä¸ªçŠ¶æ€
2. **ä»å°åˆ°å¤§** æšä¸¾çŠ¶æ€ , å¹¶æšä¸¾å¯ä»¥ **ç§»é™¤** çš„ç‚¹ , å†™å‡ºè½¬ç§»æ–¹ç¨‹ : 
    $dp[S] = min(dp[S],dp[Sub] + 1)$

### å¤æ‚åº¦åˆ†æ
**æ—¶é—´å¤æ‚åº¦ :** $O(2 ^ {n * m} * n * m)$ , å…¶ä¸­ $O(n * m)$ çš„å¼€é”€æ˜¯å¯¹äºæ¯ä¸€ä¸ªçŠ¶æ€æšä¸¾æ¯ä¸€ä¸ªå¯ä»¥ç§»é™¤çš„ç‚¹æ—¶çš„å¼€é”€
**ç©ºé—´å¤æ‚åº¦ :** $O(2 ^ {n * m})$

**å…·ä½“çœ‹ä»£ç å®ç°å³å¯ æœ‰ä»»ä½•ç–‘é—®æ¬¢è¿è¯„è®ºåŒºæŒ‡å‡º** ğŸ¬

### ä»£ç 

```cpp
const int N = 1e5 + 7;
class Solution {
public:
    int dp[N];
    int st[N];
    int removeOnes(vector<vector<int>>& grid) {
        int n,m;
        n = grid.size() , m = grid[0].size();
        int S = 0;
        // (i,j) -> i * m + j
        // S è¡¨ç¤ºå…¨éƒ¨ 1 çš„çŠ¶æ€
        for(int i = 0;i < n;i ++) {
            for(int j = 0;j < m;j ++) {
                if(grid[i][j]) S ^= (1 << (i * m + j));
            }
        }
        if(!S) return 0;
        if(n == 1 || m == 1) return 1;// å°å‰ªæ
        dp[0] = 0;
        int all = n * m;// å…¨éƒ¨ä½æ•° 
        // st[] å­˜ä»å¤§åˆ°å°çš„æ‰€æœ‰åˆæ³•çŠ¶æ€ (å­é›†æšä¸¾)
        int top = 0;
        for(int sub = S;sub;sub = (sub - 1) & S) {
            st[top ++] = sub;
        }
        // ä»å°åˆ°å¤§æšä¸¾å…¨éƒ¨çŠ¶æ€
        for(int o = top - 1;o >= 0;o --) {
            int i = st[o];// i è¡¨ç¤ºå½“å‰è¦æ±‚çš„çŠ¶æ€
            dp[i] = n;
            for(int j = 0;j < all;j ++) {
                // æšä¸¾å¯ä»¥ç§»é™¤çš„ç‚¹çš„ä½ç½®
                if(i >> j & 1) {
                    int t = i;
                    // (j / m , j % m) ä¸ºç‚¹ -> (x,y)
                    int x = j / m , y = j % m;
                    // å¤„ç† è¡Œ x
                    for(int k = 0;k < m;k ++) {
                        if(t >> (x * m + k) & 1) t ^= (1 << (x * m + k));
                    }
                    // å¤„ç† åˆ— y
                    for(int k = 0;k < n;k ++) {
                        if(t >> (k * m + y) & 1) t ^= (1 << (k * m + y));
                    }
                    // ç§»é™¤ (x,y) éœ€è¦ 1 æ¬¡ å‰©ä¸‹çš„éœ€è¦ dp[t] æ¬¡
                    dp[i] = min(dp[i],dp[t] + 1);
                }
            }
        }
        return dp[S];
    }
};
```
# 2.[Python] çŠ¶å‹dp
### è§£é¢˜æ€è·¯
ç”¨äºŒè¿›åˆ¶ 1 << (i * n + j) ä½è¡¨ç¤ºgrid[i][j]æ˜¯å¦ä¸º1çš„çŠ¶å‹
ä½¿ç”¨äº†è®°å¿†åŒ–é€’å½’å†™dp

### ä»£ç 

```python3
class Solution:
    def removeOnes(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        @lru_cache(None)
        def dfs(state):
            if not state:
                return 0
            ans = inf
            for i in range(m * n):
                if (1 << i) & state:
                    row, col = divmod(i, n)
                    nxt_state = state
                    for r in range(m):
                        if (b:= 1 << (r * n + col)) & nxt_state:
                            nxt_state ^= b
                    for c in range(n):
                        if (b:= 1 << (row * n + c)) & nxt_state:
                            nxt_state ^= b
                    ans = min(ans, dfs(nxt_state))
            return ans + 1
        
        return dfs(sum(1 << (i * n + j) if grid[i][j] else 0 for i in range(m) for j in range(n)))
```
# 3.çŠ¶æ€å‹ç¼©


### ä»£ç 

```cpp
class Solution {
public:
    int removeOnes(vector<vector<int>>& g) {
        int row = g.size();
        int col = g[0].size();
        int size = row * col;
        int bound = 1 << size;
        int ans = INT_MAX;
        for (int j = 1; j < bound; ++j) {
            bool flag = true;
            vector<int> checkX(row, 0);
            vector<int> checkY(col, 0);
            for (int m = 0; m < size; ++m) {
                if ((j & (1 << m)) == 0) {
                    continue;
                }
                int r = m / col;
                int c = m % col;
                if (!g[r][c]) {
                    flag = false;
                    break;
                }
                checkX[r] = 1;
                checkY[c] = 1;
            }
            if (!flag) {
                continue;
            }
            for (int m = 0; m < size; ++m) {
                int r = m / col;
                int c = m % col;
                if (g[r][c] == 1 && checkX[r] == 0 && checkY[c] == 0) {
                    break;
                }
                if (m == size - 1) {
                    ans = min(ans, __builtin_popcount(j));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```
# 4.BFS
```C++
#define PLL pair<__int128, __int128>

class Solution {
public:

    PLL removeAt(vector<vector<int>>& mat, int x, int y) {
        PLL p(0, 0);
        int m = mat.size(), n = mat[0].size();
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(mat[i][j] == 0 || i == x || j == y) {
                    continue;
                }
                int t = i * n + j;
                if(t < 128) {
                    p.first |= 1 << t;
                } else {
                    p.second |= 1 << (t - 128);
                }
            }
        }
        return p;
    }
    void pairToMat(PLL & p, vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                int t = i * n + j;
                if(t < 128) {
                    mat[i][j] = (p.first >> t) & 1;
                } else {
                    mat[i][j] = (p.second >> (t - 128)) & 1;
                }
            }
        }
    }

    
    
    int removeOnes(vector<vector<int>>& mat) {
        map<PLL, bool> vis;
        queue<PLL> que;
        que.push(removeAt(mat, -1, -1));
        vis[que.front()] = true;
        int step = 0;
        int m = mat.size(), n = mat[0].size();
        while(!que.empty()) {
            int cnt = que.size();
            while(cnt--) {
                if(que.front() == PLL(0, 0)) {
                    return step;
                }
                pairToMat(que.front(), mat);
                que.pop();
                for(int i = 0; i < m; ++i) {
                    for(int j = 0; j < n; ++j) {
                        if(mat[i][j]) {
                            PLL t = removeAt(mat, i, j);
                            if(!vis[t]) {
                                vis[t] = true;
                                que.push(t);
                            }
                        }
                    }
                }
                
            }
            step++;
        }

        return -1;
    }
};
```

