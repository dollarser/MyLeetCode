# 2297è·³è·ƒæ¸¸æˆ VIII
<p>ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„ä¸‹æ ‡ä» <strong>0</strong>&nbsp;å¼€å§‹çš„æ•´æ•°æ•°ç»„ <code>nums</code>ã€‚åˆå§‹ä½ç½®ä¸ºä¸‹æ ‡ <code>0</code>ã€‚å½“ <code>i &lt; j</code> æ—¶ï¼Œä½ å¯ä»¥ä»ä¸‹æ ‡ <code>i</code> è·³è½¬åˆ°ä¸‹æ ‡ <code>j</code>:</p>

<ul>
	<li>å¯¹äºåœ¨&nbsp;<code>i &lt; k &lt; j</code>&nbsp;èŒƒå›´å†…çš„æ‰€æœ‰ä¸‹æ ‡ <code>k</code> æœ‰&nbsp;<code>nums[i] &lt;= nums[j]</code> å’Œ&nbsp;<code>nums[k] &lt; nums[i]</code> , æˆ–è€…</li>
	<li>å¯¹äºåœ¨&nbsp;<code>i &lt; k &lt; j</code>&nbsp;èŒƒå›´å†…çš„æ‰€æœ‰ä¸‹æ ‡ <code>k</code>&nbsp;æœ‰&nbsp;<code>nums[i] &gt; nums[j]</code> å’Œ&nbsp;<code>nums[k] &gt;= nums[i]</code>&nbsp;ã€‚</li>
</ul>

<p>ä½ è¿˜å¾—åˆ°äº†ä¸€ä¸ªé•¿åº¦ä¸º <code>n</code> çš„æ•´æ•°æ•°ç»„ <code>costs</code>ï¼Œå…¶ä¸­ <code>costs[i]</code> è¡¨ç¤ºè·³è½¬<strong>åˆ°</strong>ä¸‹æ ‡ <code>i</code> çš„ä»£ä»·ã€‚</p>

<p>è¿”å›<em>è·³è½¬åˆ°</em>ä¸‹æ ‡ <em><code>n - 1</code> çš„æœ€å°ä»£ä»·ã€‚</em></p>

<p><strong>ç¤ºä¾‹ 1:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> nums = [3,2,4,4,1], costs = [3,7,6,4,2]
<strong>è¾“å‡º:</strong> 8
<strong>è§£é‡Š:</strong> ä»ä¸‹æ ‡ 0 å¼€å§‹ã€‚
- ä»¥ costs[2]= 6 çš„ä»£ä»·è·³è½¬åˆ°ä¸‹æ ‡ 2ã€‚
- ä»¥ costs[4]= 2 çš„ä»£ä»·è·³è½¬åˆ°ä¸‹æ ‡ 4ã€‚
æ€»ä»£ä»·æ˜¯ 8ã€‚å¯ä»¥è¯æ˜ï¼Œ8 æ˜¯æ‰€éœ€çš„æœ€å°ä»£ä»·ã€‚
å¦å¤–ä¸¤ä¸ªå¯èƒ½çš„è·¯å¾„æ˜¯:ä¸‹æ ‡ 0 -&gt; 1 -&gt; 4 å’Œä¸‹æ ‡ 0 -&gt; 2 -&gt; 3 -&gt; 4ã€‚
å®ƒä»¬çš„æ€»ä»£ä»·åˆ†åˆ«ä¸º9å’Œ12ã€‚
</pre>

<p><strong>ç¤ºä¾‹&nbsp;2:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> nums = [0,1,2], costs = [1,1,1]
<strong>è¾“å‡º:</strong> 2
<strong>è§£é‡Š:</strong> ä»ä¸‹æ ‡ 0 å¼€å§‹ã€‚
- ä»¥ costs[1] = 1 çš„ä»£ä»·è·³è½¬åˆ°ä¸‹æ ‡ 1ã€‚
- ä»¥ costs[2] = 1 çš„ä»£ä»·è·³è½¬åˆ°ä¸‹æ ‡ 2ã€‚
æ€»ä»£ä»·æ˜¯ 2ã€‚æ³¨æ„æ‚¨ä¸èƒ½ç›´æ¥ä»ä¸‹æ ‡ 0 è·³è½¬åˆ°ä¸‹æ ‡ 2ï¼Œå› ä¸º nums[0] &lt;= nums[1]ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>è§£é‡Š:</strong></p>

<ul>
	<li><code>n == nums.length == costs.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i], costs[i] &lt;= 10<sup>5</sup></code></li>
</ul>
































# è§£é¢˜:
# 1.Java å•è°ƒé˜Ÿåˆ— + DP è¯¦è§£
è¿™é“é¢˜çƒ¦åœ¨ç†è§£é¢˜ç›®æ„æ€ä¸Šã€‚

é¦–å…ˆï¼Œå¯ä»¥æ˜ç¡®çš„æ˜¯ï¼Œæˆ‘ä»¬åªèƒ½å¾€åè·³ï¼Œä¸èƒ½å›å¤´ã€‚å¦‚æœiç‚¹å¯ä»¥åˆ°è¾¾jç‚¹ï¼Œé‚£ä¹ˆiï¼Œjéœ€è¦æ»¡è¶³é¢˜ç›®ç»™å®šçš„ä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€ã€‚è¿™ä¸¤ä¸ªæ¡ä»¶æ˜¯ç‹¬ç«‹çš„ï¼Œä¸å¯èƒ½æœ‰ä¸€ä¸ªç‚¹æ—¢æ»¡è¶³æ¡ä»¶1ï¼Œåˆæ»¡è¶³æ¡ä»¶2ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸¤ä¸ªæ¡ä»¶ç‹¬ç«‹è¿›è¡Œæ€è€ƒã€‚

å…ˆæ¥çœ‹çœ‹ç¬¬äºŒä¸ªæ¡ä»¶ï¼Œ`nums[i] > nums[j] and nums[k] >= nums[i] for all indexes k in the range i < k < j.` æ„æ€å°±æ˜¯ï¼Œiä½çš„æ•°å­—æ¯”jä½çš„æ•°å­—å¤§ï¼Œå¹¶ä¸”ï¼Œiå’Œjä¸­é—´çš„ä¹‹é—´çš„æ‰€æœ‰æ•°å­—éƒ½å¤§äºç­‰äºiä½çš„æ•°å­—ï¼Œæ¢è¨€ä¹‹ï¼Œjå¿…é¡»æ˜¯ç¬¬ä¸€ä¸ªå°äºiçš„æ•°å­—ï¼Œå³ä½¿è¿˜æœ‰ä¸€ä¸ªindexä¸ºj2çš„æ•°å­—ä¹Ÿå°äºnums[i]ï¼Œiä¹Ÿæ— æ³•è·³åˆ°j2ï¼Œå› ä¸ºjåœ¨iå’Œj2ä¹‹é—´ï¼Œå¹¶ä¸”nums[j]å°äºnums[i]ï¼Œä¸æ»¡è¶³æ¡ä»¶äº†ã€‚æ‰€ä»¥ï¼Œå¯¹äºæ¯ä¸€ä¸ªindex iæ¥è¯´ï¼Œåœ¨è¿™ä¸ªæ¡ä»¶ä¸‹æœ€å¤šåªå¯èƒ½åˆ°è¾¾ä¸€ä¸ªjï¼Œä¹Ÿæœ‰å¯èƒ½æ²¡æœ‰æ»¡è¶³æ¡ä»¶çš„jã€‚
é‚£ä¹ˆï¼Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥ç”¨ä¸€ä¸ªé€’å¢çš„å•è°ƒæ ˆï¼Œå¦‚æœå‡ºç°äº†ä¸€ä¸‹è¾ƒå°çš„æ•°å­—ï¼Œè¯´æ˜æ ˆå†…çš„indexå¯ä»¥è·³åˆ°å½“å‰ä½ç½®ã€‚

```java
Stack<Integer> maxStack = new Stack<>(); // å­˜æ”¾indexï¼ŒæŒ‰ç…§æ•°å€¼é€’å¢
for (int j = 0; j < nums.length; j++) {
    while (!maxStack.isEmpty() && nums[maxStack.peek()] > nums[j]) {
        int i = maxStack.pop(); // nums[j]æ˜¯iä¹‹åç¬¬ä¸€ä¸ªæ¯”nums[i]å°çš„æ•°å­—
        // è€ƒè™‘ä» i -> jçš„æƒ…å†µ
    }
}
```

åŒç†ï¼Œæˆ‘ä»¬è€ƒè™‘ç¬¬ä¸€ä¸ªæ¡ä»¶ï¼Œ`nums[i] <= nums[j] and nums[k] < nums[i] for all indexes k in the range i < k < j`ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœiçš„æ•°å­—å°äºç­‰äºjçš„æ•°å­—ï¼Œå¹¶ä¸”iï¼Œjä¹‹é—´çš„æ•°å­—éƒ½å°äºnums[i]ï¼Œiå¯ä»¥åˆ°è¾¾jï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨nums[j]æ˜¯ç¬¬ä¸€ä¸ªå¤§äºç­‰äºnums[i]çš„æ•°å­—ã€‚é‚£ä¹ˆï¼Œä¸ä¸Šä¸€ä¸ªæ¡ä»¶ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªé€’å‡çš„å•è°ƒæ ˆï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºnums[i]çš„æ•°å­—ã€‚

```java
Stack<Integer> minStack = new Stack<>(); // å­˜æ”¾indexï¼ŒæŒ‰ç…§æ•°å€¼é€’å‡
for (int j = 0; j < nums.length; j++) {
    while (!minStack.isEmpty() && nums[minStack.peek()] <= nums[j]) {
        int i = maxStack.pop(); // nums[j]æ˜¯iä¹‹åç¬¬ä¸€ä¸ªå¤§äºç­‰äºnums[i]çš„æ•°å­—
        // è€ƒè™‘ä» i -> jçš„æƒ…å†µ
    }
}
```

æœ€åè¿˜æœ‰ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯ï¼Œå¦‚ä½•è€ƒè™‘ä»iåˆ°jçš„æˆæœ¬æƒ…å†µã€‚æˆ‘ä»¬éœ€è¦ç”¨ä¸€ä¸ªdpåˆ—è¡¨ï¼Œæ¥ç»´æŠ¤åˆ°è¾¾æ¯ä¸€ä¸ªindexçš„æœ€å°costã€‚
é‚£ä¹ˆï¼Œæœ‰ä¸¤ä¸ªå¯èƒ½çš„é—®é¢˜ï¼š
1. æ˜¯ä¸æ˜¯æˆ‘ä»¬åœ¨åˆ°è¾¾ä½ç½®jæ—¶ï¼Œjä¹‹å‰çš„ä½ç½®éƒ½å·²ç»è®¡ç®—costå®Œæˆï¼Ÿ
    æ˜¯çš„ã€‚å› ä¸ºæˆ‘ä»¬æ˜¯ä»å·¦åˆ°å³éå†çš„ï¼Œåœ¨å¾ªç¯ä½“å†…è®¡ç®—å½“å‰ä½ç½®çš„costï¼Œæ‰€ä»¥ï¼Œåœ¨åˆ°è¾¾ä½ç½®jä¹‹å‰ï¼Œå‰é¢çš„indexä¸€å®šæ˜¯å·²ç»è®¡ç®—ç»“æŸäº†ï¼Œä¸å­˜åœ¨åˆ°è¾¾ä½ç½®jä¹‹åï¼Œå¯¹äºä½ç½®jä¹‹å‰çš„dpå€¼æ›´æ–°ã€‚
2. æ˜¯ä¸æ˜¯åˆ°è¾¾ä½ç½®jä¹‹å‰ï¼Œæ‰€æœ‰çš„ä½ç½®ä¸€å®šéƒ½èƒ½åˆ°è¾¾ï¼Ÿ
    æ˜¯çš„ï¼Œå› ä¸ºç›¸é‚»çš„ä½ç½®ï¼Œä¸€å®šè¦ä¹ˆæ»¡è¶³æ¡ä»¶1ï¼Œè¦ä¹ˆæ»¡è¶³æ¡ä»¶2ï¼Œä¸¤ä¸ªæ¡ä»¶äº’è¡¥ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ä»ä½ç½®0ä¸€å®šå¯ä»¥åˆ°è¾¾æ‰€æœ‰çš„ä½ç½®ã€‚
    
æ‰€æœ‰çš„é—®é¢˜éƒ½è§£å†³å•¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å†™ä»£ç äº†ã€‚

```java
public long minCost(int[] nums, int[] costs) {
    int n = nums.length;
    long[] dp = new long[n];
    Arrays.fill(dp, Long.MAX_VALUE);
    dp[0] = 0;

    Stack<Integer> maxStack = new Stack<>(), minStack = new Stack<>();
    for (int j = 0; j < n; j++) {
        while (!minStack.isEmpty() && nums[minStack.peek()] <= nums[j]) {
            int i = minStack.pop();
            dp[j] = Math.min(dp[j], dp[i] + costs[j]);
        }
        minStack.push(j);
        while (!maxStack.isEmpty() && nums[maxStack.peek()] > nums[j]) {
            dp[j] = Math.min(dp[j], dp[maxStack.pop()] + costs[j]);
        }
        maxStack.push(j);
    }
    return dp[n-1];
}
```

ç‚¹[è¿™é‡Œ](https://esther.fun/tech/monotonic-stack-and-monotonic-queue/)äº†è§£æ›´å¤šå…³äºã€Œå•è°ƒæ ˆå’Œå•è°ƒé˜Ÿåˆ—ã€çš„ç»ƒä¹ ä¸è§£ç­”ã€‚ä¸€èµ·æˆä¸ºå•è°ƒç‹è€…å§ï¼


# 2.go  å•è°ƒæ ˆ+åŠ¨æ€è§„åˆ’
### è§£é¢˜æ€è·¯
ä»é¢˜æ„å¯çŸ¥ ä¸€ä¸ªä¸‹æ ‡jåªèƒ½ç”±å‰ä¸€ä¸ªå°äºç­‰äºnums[j]æˆ–è€…å¤§äºç­‰äºnums[j]çš„ä¸‹æ ‡è·³è¿‡æ¥ï¼Œæˆ‘ä»¬ç”¨ä¸¤ä¸ªå•è°ƒæ ˆç»´æŠ¤å‰ä¸€ä¸ªå°äºç­‰äºnums[j]å’Œå¤§äºç­‰äºnums[j]çš„ä¸‹æ ‡ï¼Œè¿›è¡Œè½¬ç§»ã€‚

### ä»£ç 

```golang
func minCost(nums []int, costs []int) int64 {
	n := len(nums)
	dp := make([]int, n)
	min := []int{0}
	max := []int{0}
	for i := 1; i < n; i++ {
		res := 10000000001
		for len(min) > 0 && nums[min[len(min)-1]] <= nums[i] {
			top := min[len(min)-1]
			min = min[:len(min)-1]
			if dp[top] < res {
				res = dp[top]
			}
		}
		min = append(min, i)
		for len(max) > 0 && nums[max[len(max)-1]] > nums[i] {
			top := max[len(max)-1]
			max = max[:len(max)-1]
			if dp[top] < res {
				res = dp[top]
			}
		}
		max = append(max, i)
		dp[i] = res + costs[i]
	}
	return int64(dp[n-1])
}
```
# 3.python å•è°ƒæ ˆå»ºå›¾+æœ€çŸ­è·¯
### è§£é¢˜æ€è·¯
1. å•è°ƒæ ˆæ±‚å‡ºæ¯ä¸ªå…ƒç´ ä½œä¸ºä¸¥æ ¼æœ€å¤§å€¼/éä¸¥æ ¼æœ€å°å€¼çš„å½±å“èŒƒå›´
2. å»ºå›¾ï¼Œdijkstra æ±‚ 0 åˆ° n-1 çš„æœ€çŸ­è·¯
æ³¨æ„åˆ°åŸå›¾æ˜¯ä¸€ä¸ªæ‹“æ‰‘å›¾(æ— ç¯)ï¼Œå› æ­¤æ±‚æœ€çŸ­è·¯ä¹Ÿå¯ä»¥ç”¨ dp O(n)æ±‚å‡º

### ä»£ç 

```python3 []
class Solution:
    def minCost(self, nums: List[int], costs: List[int]) -> int:
        n = len(nums)
        maxRange = getRange(nums, isMax=True, isRightStrict=True)
        minRange = getRange(nums, isMax=False, isRightStrict=False)
        adjMap = defaultdict(lambda: defaultdict(lambda: int(1e20)))
        for cur, (next1, next2) in enumerate(zip(maxRange, minRange)):
            next1, next2 = next1 + 1, next2 + 1
            adjMap[cur][next1] = costs[next1] if next1 < n else int(1e20)
            adjMap[cur][next2] = costs[next2] if next2 < n else int(1e20)
        return dijkstra(adjMap, 0, n - 1)

##############################################
def getRange(nums: List[int], *, isMax=False, isRightStrict=False,) -> List[int]:
    def compareRight(stackValue: int, curValue: int) -> bool:
        if isRightStrict and isMax:
            return stackValue <= curValue
        elif isRightStrict and not isMax:
            return stackValue >= curValue
        elif not isRightStrict and isMax:
            return stackValue < curValue
        else:
            return stackValue > curValue

    n = len(nums)
    rightMost = [n - 1] * n
    stack = []
    for i in range(n):
        while stack and compareRight(nums[stack[-1]], nums[i]):
            rightMost[stack.pop()] = i - 1
        stack.append(i)
    return rightMost

##############################################
from collections import defaultdict
from heapq import heappop, heappush
from typing import DefaultDict, Hashable, List, Optional, TypeVar, overload

INF = int(1e20)
Vertex = TypeVar('Vertex', bound=Hashable)
Graph = DefaultDict[Vertex, DefaultDict[Vertex, int]]

@overload
def dijkstra(adjMap: Graph, start: Vertex) -> DefaultDict[Vertex, int]:
    ...

@overload
def dijkstra(adjMap: Graph, start: Vertex, end: Vertex) -> int:
    ...

def dijkstra(adjMap: Graph, start: Vertex, end: Optional[Vertex] = None):
    dist = defaultdict(lambda: INF)
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        curDist, cur = heappop(pq)
        if dist[cur] < curDist:
            continue
        if end is not None and cur == end:
            return curDist
        for next in adjMap[cur]:
            if dist[next] > dist[cur] + adjMap[cur][next]:
                dist[next] = dist[cur] + adjMap[cur][next]
                heappush(pq, (dist[next], next))

    return INF if end is not None else dist
```

```python3 []
class Solution:
    def minCost(self, nums: List[int], costs: List[int]) -> int:
        n = len(nums)
        maxRange = getRange(nums, isMax=True, isRightStrict=True)
        minRange = getRange(nums, isMax=False, isRightStrict=False)
        adjMap = defaultdict(lambda: defaultdict(lambda: int(1e20)))
        deg = defaultdict(int)
        for cur, (next1, next2) in enumerate(zip(maxRange, minRange)):
            next1, next2 = next1 + 1, next2 + 1
            adjMap[cur][next1] = costs[next1] if next1 < n else int(1e20)
            adjMap[cur][next2] = costs[next2] if next2 < n else int(1e20)
            deg[next1] += 1
            deg[next2] += 1

        queue = deque([0])
        dist = defaultdict(lambda: int(1e20), {0: 0})
        while queue:
            cur = queue.popleft()
            for next in adjMap[cur]:
                dist[next] = min(dist[next], dist[cur] + adjMap[cur][next])
                deg[next] -= 1
                if deg[next] == 0:
                    queue.append(next)

        return dist[n - 1]

def getRange(nums: List[int], *, isMax=False, isRightStrict=False,) -> List[int]:
    def compareRight(stackValue: int, curValue: int) -> bool:
        if isRightStrict and isMax:
            return stackValue <= curValue
        elif isRightStrict and not isMax:
            return stackValue >= curValue
        elif not isRightStrict and isMax:
            return stackValue < curValue
        else:
            return stackValue > curValue

    n = len(nums)
    rightMost = [n - 1] * n
    stack = []
    for i in range(n):
        while stack and compareRight(nums[stack[-1]], nums[i]):
            rightMost[stack.pop()] = i - 1
        stack.append(i)
    return rightMost
```
# 4.ã€daydayUpppğŸˆã€‘å•è°ƒé˜Ÿåˆ— + DP
### è§£é¢˜æ€è·¯

æŒ‰ç…§é¢˜ç›®çš„ **è·³è·ƒçº¦æŸè§„åˆ™** å¯ä»¥å‘ç°ï¼Œæ¯ä¸€ä¸ªç‚¹ $i$ æœ€å¤šå¾€ååªèƒ½æœ‰ä¸¤ä¸ªç‚¹ï¼Œä¸”å¯ä»¥ç”¨ **å•è°ƒé˜Ÿåˆ—** æ¥æ‰¾åˆ°æ¯ä¸€ä¸ªç‚¹ $i$ å¾€åèƒ½è·³è·ƒçš„ç‚¹ã€‚ç„¶åè®¾ï¼š$\textit{dp}[i]$ è¡¨ç¤ºèµ°åˆ°ä½ç½® $i$ çš„æœ€å°å¼€é”€ï¼Œè½¬ç§»å°±æ˜¯ä»èƒ½åˆ° $i$ çš„ä½ç½®æ¥è¿›è¡Œè½¬ç§»ã€‚

**å…·ä½“çœ‹ä»£ç æ³¨é‡Šå³å¯ï¼Œæœ‰ä»»ä½•ç–‘é—®æ¬¢è¿è¯„è®ºåŒºæŒ‡å‡º** ğŸ¬

### ä»£ç 

```cpp
class Solution {
public:
    vector<long long> dp;
    long long minCost(vector<int>& nums, vector<int>& costs) {
        // å•è°ƒæ ˆè¿è¾¹
        int n = nums.size();
        long long INF = 1e15;
        dp.resize(n, INF);
        deque<int> q;
        deque<int> p;
        dp[0] = 0;
        for (int i = 0; i < n; ++i) {
            while (!q.empty() && nums[q.back()] < nums[i]) {
                auto t = q.back();
                q.pop_back();
                dp[i] = min(dp[i], dp[t] + costs[i]);
            }
            if (!q.empty() && nums[q.back()] == nums[i]) {
                auto t = q.back();
                q.pop_back();
                dp[i] = min(dp[i], dp[t] + costs[i]);
            }
            q.push_back(i);
            
            while (!p.empty() && nums[p.back()] > nums[i]) {
                auto t = p.back();
                p.pop_back();
                dp[i] = min(dp[i], dp[t] + costs[i]);
            }
            p.push_back(i);
        }
        return dp[n - 1];
    }
};
```
