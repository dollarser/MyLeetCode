# 2313äºŒå‰æ ‘ä¸­å¾—åˆ°ç»“æœæ‰€éœ€çš„æœ€å°‘ç¿»è½¬æ¬¡æ•°
<p>ç»™å®š<strong>äºŒå‰æ ‘</strong>çš„æ ¹ <code>root</code>ï¼Œå…·æœ‰ä»¥ä¸‹å±æ€§:</p>

<ul>
	<li><strong>å¶èŠ‚ç‚¹&nbsp;</strong>çš„å€¼ä¸º <code>0</code> æˆ– <code>1</code>ï¼Œåˆ†åˆ«è¡¨ç¤º <code>false</code> å’Œ <code>true</code>ã€‚</li>
	<li><strong>éå¶èŠ‚ç‚¹</strong>çš„å€¼ä¸º <code>2</code>ã€<code>3</code>ã€<code>4</code>ã€<code>5</code>ï¼Œåˆ†åˆ«è¡¨ç¤ºå¸ƒå°”è¿ç®—&nbsp;<code>OR</code>,&nbsp;<code>AND</code>,&nbsp;<code>XOR</code>,&nbsp;<code>NOT</code>ã€‚</li>
</ul>

<p>æ‚¨è¿˜å°†å¾—åˆ°ä¸€ä¸ªå¸ƒå°”å‹&nbsp;<code>result</code>ï¼Œè¿™æ˜¯ <code>root</code>&nbsp;èŠ‚ç‚¹çš„æœŸæœ›&nbsp;<strong>è¯„ä»·</strong><strong>&nbsp;</strong>ç»“æœã€‚</p>

<p data-group="1-1">å¯¹èŠ‚ç‚¹çš„è¯„ä»·è®¡ç®—å¦‚ä¸‹:</p>

<ul>
	<li>å¦‚æœèŠ‚ç‚¹æ˜¯å¶èŠ‚ç‚¹ï¼Œåˆ™è¯„ä»·æ˜¯èŠ‚ç‚¹çš„&nbsp;<strong>å€¼</strong>ï¼Œå³ <code>true</code> æˆ–&nbsp;<code>false</code>.</li>
	<li>å¦åˆ™, å°†å…¶å€¼çš„å¸ƒå°”è¿ç®—åº”ç”¨äºå­èŠ‚ç‚¹çš„&nbsp;<strong>è¯„ä»·</strong>ï¼Œè¯¥èŠ‚ç‚¹çš„&nbsp;<strong>è¯„ä»·&nbsp;</strong>å³ä¸ºå¸ƒå°”è¿ç®—åçš„ç»“æœã€‚</li>
</ul>

<p>åœ¨ä¸€ä¸ªæ“ä½œä¸­ï¼Œæ‚¨å¯ä»¥&nbsp;<strong>ç¿»è½¬&nbsp;</strong>ä¸€ä¸ªå¶èŠ‚ç‚¹ï¼Œè¿™å°†å¯¼è‡´ä¸€ä¸ª <code>false</code>&nbsp;èŠ‚ç‚¹å˜ä¸º <code>true</code>&nbsp;èŠ‚ç‚¹ï¼Œä¸€ä¸ª <code>true</code>&nbsp;èŠ‚ç‚¹å˜ä¸º <code>false</code>&nbsp;èŠ‚ç‚¹ã€‚</p>

<p>è¿”å›<em>éœ€è¦æ‰§è¡Œçš„æœ€å°æ“ä½œæ•°ï¼Œä»¥ä½¿ </em><code>root</code><em>&nbsp;çš„</em><em>è¯„ä»·å¾—åˆ°&nbsp;</em><code>result</code>ã€‚å¯ä»¥è¯æ˜ï¼Œæ€»æœ‰åŠæ³•è¾¾åˆ° <code>result</code>ã€‚</p>

<p data-group="1-1"><strong>å¶èŠ‚ç‚¹&nbsp;</strong>æ˜¯æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚</p>

<p>æ³¨æ„: <code>NOT</code> èŠ‚ç‚¹åªæœ‰å·¦å­©å­æˆ–åªæœ‰å³å­©å­ï¼Œä½†å…¶ä»–éå¶èŠ‚ç‚¹åŒæ—¶æ‹¥æœ‰å·¦å­©å­å’Œå³å­©å­ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/20/operationstree.png" style="width: 500px; height: 179px;" />
<pre>
<strong>è¾“å…¥:</strong> root = [3,5,4,2,null,1,1,1,0], result = true
<strong>è¾“å‡º:</strong> 2
<strong>è§£é‡Š:</strong>
å¯ä»¥è¯æ˜ï¼Œè‡³å°‘éœ€è¦ç¿»è½¬ 2 ä¸ªèŠ‚ç‚¹æ‰èƒ½ä½¿æ ‘çš„ root è¯„ä»·ä¸º trueã€‚ä¸Šé¢çš„å›¾æ˜¾ç¤ºäº†å®ç°è¿™ä¸€ç›®æ ‡çš„ä¸€ç§æ–¹æ³•ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> root = [0], result = false
<strong>è¾“å‡º:</strong> 0
<strong>è§£é‡Š:</strong>
æ ‘çš„ root çš„è¯„ä»·å·²ç»ä¸º falseï¼Œæ‰€ä»¥ 0 ä¸ªèŠ‚ç‚¹å¿…é¡»ç¿»è½¬ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤º:</strong></p>

<ul>
	<li>æ ‘ä¸­çš„èŠ‚ç‚¹æ•°åœ¨ <code>[1, 10<sup>5</sup>]</code>&nbsp;èŒƒå›´å†…ã€‚</li>
	<li><code>0 &lt;= Node.val &lt;= 5</code></li>
	<li><code>OR</code>, <code>AND</code>, <code>XOR</code>&nbsp;èŠ‚ç‚¹æœ‰&nbsp;<code>2</code> ä¸ªå­èŠ‚ç‚¹ã€‚</li>
	<li><code>NOT</code> åªæœ‰ä¸€ä¸ª&nbsp;<code>1</code> å­èŠ‚ç‚¹ã€‚</li>
	<li>å¶èŠ‚ç‚¹çš„å€¼ä¸º <code>0</code> æˆ–&nbsp;<code>1</code>.</li>
	<li>éå¶èŠ‚ç‚¹çš„å€¼ä¸º<code>2</code>, <code>3</code>, <code>4</code>,&nbsp;<code>5</code>.</li>
</ul>
































# è§£é¢˜:
# 1.python æ ‘å½¢dp
### è§£é¢˜æ€è·¯
åŠ å¼ºç‰ˆé¢˜è§£ï¼š[1896. åè½¬è¡¨è¾¾å¼å€¼çš„æœ€å°‘æ“ä½œæ¬¡æ•°](https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution/zhong-zhui-biao-da-shi-gou-zao-er-cha-bi-gman/)

### ä»£ç 

```python3
MAPPING = {0: False, 1: True, 2: or_, 3: and_, 4: xor, 5: not_}
INF = int(1e20)

class Solution:
    def minimumFlips(self, root: Optional['TreeNode'], result: bool) -> int:
        """æ ‘çš„å¶å­ä¸ºæ“ä½œæ•°ï¼Œæ ‘çš„éå¶å­ä¸ºè¿ç®—ç¬¦ï¼Œæ±‚å¶å­èŠ‚ç‚¹çš„æœ€å°ç¿»è½¬æ¬¡æ•°"""

        def dfs(root: Optional['TreeNode']) -> List[int]:
            """è¿”å›(å˜ä¸ºFALSEçš„æœ€å°æ“ä½œæ¬¡æ•°,å˜ä¸ºTRUEçš„æœ€å°æ“ä½œæ¬¡æ•°)"""
            if not root:
                return [INF, INF]
            if root.val in (0, 1):
                return [int(root.val == 1), int(root.val == 0)]
            if root.val == 5:
                return dfs(root.left)[::-1] if root.left else dfs(root.right)[::-1]

            res, leftRes, rightRes = [INF, INF], dfs(root.left), dfs(root.right)
            for left, leftFlip in enumerate(leftRes):
                for right, rigthFlip in enumerate(rightRes):
                    value = MAPPING[root.val](left, right)
                    res[value] = min(res[value], leftFlip + rigthFlip)

            return res

        return dfs(root)[result & 1]
```
# 2.ã€é’°å¨˜å¨˜ã€‘2313. Minimum Flips in Binary Tree to Get Result é¢˜ç›®æ„æ€+DFSé¢˜è§£
### é¢˜ç›®é‡Šä¹‰
1. æœ‰é¢—æ ‘ï¼Œå¶å­ä»£è¡¨å…·ä½“çš„å¸ƒå°”å€¼ï¼Œ0 ä»£è¡¨ false, 1 ä»£è¡¨ true
2. éå¶å­èŠ‚ç‚¹æœ‰4ä¸­æ“ä½œï¼Œåˆ†åˆ«ç”¨ 2 ä»£è¡¨ OR, 3 ä»£è¡¨ AND , 4 ä»£è¡¨ XOR, 5 ä»£è¡¨ NOT æ ‡è¯†
3. éå¶å­èŠ‚ç‚¹NOTæ“ä½œæœ‰å·¦å­æˆ–å³å­èŠ‚ç‚¹ï¼Œå…¶ä»–æ“ä½œå¿…æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
4. æ±‚ç»è¿‡å¸ƒå°”å€¼è®¡ç®—åï¼Œæœ€ç»ˆè®©æ ¹èŠ‚ç‚¹å˜æˆç›®æ ‡å¸ƒå°”å€¼çš„æœ€å°‘ç¿»è½¬å­èŠ‚ç‚¹æ¬¡æ•°

### æ–¹æ³•ï¼šDFS
1. ä¸è®ºä»»ä½•é€»è¾‘è®¡ç®—ï¼Œæˆ‘ä»¬æŠŠå­èŠ‚ç‚¹å˜æˆtrue/falseçš„æ¬¡æ•°éƒ½ç®—å‡ºæ¥å°±å¯è§£äº†ï¼Œä½¿ç”¨æ•°ç»„çš„ä¸¤ä¸ªä½ç½®åˆ†åˆ«è¡¨ç¤ºtrue/falseæ“ä½œæ¬¡æ•°
2. å¯¹äºç©ºèŠ‚ç‚¹ï¼Œæ— éœ€æ“ä½œï¼Œè¿”å› [0,0]
3. å¯¹äºå¶å­èŠ‚ç‚¹ï¼Œæ˜¯true,è¿”å› [1,0] false è¿”å› [0,1]
4. éå¶å­ï¼Œé€»è¾‘ï¼š
    - OR
        - true: å·¦å³æœ‰ä¸€ä¸ªtrueå°±å¯ä»¥ï¼Œæ±‚å·¦å³å­èŠ‚ç‚¹å˜æˆtrueçš„æœ€å°æ¬¡æ•° min(lTrue,rTrue)
        - false:å·¦å³éœ€è¦éƒ½å˜false,æ±‚å·¦å³å­èŠ‚ç‚¹å˜æˆfalseçš„å’Œï¼ŒlFalse+rFalse
    - AND
        - true: å·¦å³éƒ½è¦å˜æˆtrue,æ±‚å·¦å³å­èŠ‚ç‚¹å˜æˆtrueçš„å’Œ lTrue+rTrue
        - false:å·¦å³ä¸€ä¸ªå˜æˆfalse,æ±‚å·¦å³å­èŠ‚ç‚¹å˜æˆfalseçš„è¾ƒå°å€¼ min(lFalse,rFalse)
    - XOR
        - true: å·¦trueå³falseæˆ–è€…å·¦falseå³trueæ±‚ä¸¤è€…å’Œçš„è¾ƒå°å€¼ min(lTrue+rFalse,lFalse+rTrue)
        - false:å·¦å³å€¼ç›¸åŒï¼Œä¹Ÿå°±æ˜¯å·¦å³éƒ½æ˜¯trueä¸å·¦å³éƒ½falseæ±‚è¾ƒå°å€¼ min(LTrue,rTrue,lFalse+rFalse)
    - NOT
        - true: éç©ºä¸€è¾¹æ±‚false,ç”±äºå‰é¢è®¾ç½®ç©ºèŠ‚ç‚¹å€¼ä¸º0ï¼Œå¯ç›´æ¥æ±‚ lFalse+rFalse
        - false,éç©ºæ±‚true,ç”±äºå‰é¢è®¾ç½®ç©ºèŠ‚ç‚¹å€¼ä¸º0ï¼Œå¯ç›´æ¥æ±‚ lTrue+rTrue

``` java
class Solution {
        private final int FALSE = 0;
        private final int TRUE = 1;
        private final int OR = 2;
        private final int AND = 3;
        private final int XOR = 4;
        private final int NOT = 5;

        public int minimumFlips(TreeNode root, boolean result) {
            int[] ans = getTime(root);
            return result?ans[0]:ans[1];
        }

        private int[] getTime(TreeNode root){
            if(root==null) return new int[]{0,0};
            if(root.val == TRUE || root.val == FALSE) {
                return root.val==TRUE?new int[]{0,1}:new int[]{1,0};
            }
            int[] lRes = getTime(root.left);
            int[] rRes = getTime(root.right);
            switch (root.val){
                case OR: return new int[]{Math.min(lRes[0],rRes[0]),lRes[1]+rRes[1]};
                case AND: return new int[]{lRes[0]+rRes[0],Math.min(lRes[1],rRes[1])};
                case XOR: return new int[]{Math.min(lRes[0]+rRes[1],lRes[1]+rRes[0]),Math.min(lRes[0]+rRes[0],lRes[1]+rRes[1])};
                case NOT: return new int[]{lRes[1]+rRes[1],lRes[0]+rRes[0]};
            }
            return new int[]{0,0};
        }
        
    }

```
# 3.ã€daydayUpppğŸˆã€‘æ ‘å½¢DPï¼šè¿”å›ä¸¤ç§æƒ…å†µå’Œè®°å¿†åŒ–æœç´¢ä¸¤ç§æ–¹æ³•
### è§£é¢˜æ€è·¯

**æ ‘å½¢DP** å¤„ç†å³å¯ã€‚

**å…·ä½“çœ‹ä»£ç ç†è§£å³å¯ï¼Œæœ‰ä»»ä½•ç–‘é—®æ¬¢è¿è¯„è®ºåŒºæŒ‡å‡º** ğŸ¬

### ä»£ç 

```cpp
// è¿”å› {ç”Ÿæˆ 1 çš„æœ€å°‘æ¬¡æ•°ï¼Œ ç”Ÿæˆ 0 çš„æœ€å°‘æ¬¡æ•°}
class Solution {
public:
    const int INF = 0x3f3f3f3f;
    pair<int, int> dfs(TreeNode* c) {
        if (c->val < 2) {
            return {c->val ^ 1, c->val};
        } else {
            int res = INF;
            if (c->val == 5) {
                // not
                pair<int, int> t;
                if (c->left) t = dfs(c->left);
                else t = dfs(c->right);
                return {t.second, t.first};
            } else {
                auto t1 = dfs(c->left);
                auto t2 = dfs(c->right);
                if (c->val == 2) {
                    // or
                    return {
                        min(t1.first + t2.first,
                            min(t1.second + t2.first, t1.first + t2.second)
                        ), t1.second + t2.second
                    };
                } else if (c->val == 3) {
                    // and
                    return {
                        t1.first + t2.first, min(
                            t1.first + t2.second, min(
                                t1.second + t2.first, t1.second + t2.second
                            )
                        )
                    };
                } else if (c->val == 4) {
                    // xor
                    return {
                        min(t1.first + t2.second, t1.second + t2.first), 
                        min(t1.first + t2.first, t1.second + t2.second)
                    };
                }
            }
        }
        return {-1, -1};
    }
    int minimumFlips(TreeNode* root, bool result) {
        auto t = dfs(root);
        if (result) return t.first;
        return t.second;
    }
};
```

```cpp
// dp[s][c] è¡¨ç¤ºå­æ ‘ c å¾—åˆ°çŠ¶æ€ s çš„æœ€å°‘æ¬¡æ•°
class Solution {
public:
    const int INF = 0x3f3f3f3f;
    unordered_map<TreeNode*, int> dp[2];
    int dfs(TreeNode* c, int s) {
        if (dp[s].count(c)) return dp[s][c];
        if (c->val < 2) {
            if (c->val != s) dp[s][c] = 1;
            else dp[s][c] = 0;
        } else {
            int res = INF;
            if (c->val == 5) {
                // not
                if (c->left) res = dfs(c->left, !s);
                else res = dfs(c->right, !s);
            } else {
                for (int i = 0; i < 2; ++i) {
                    for (int j = 0; j < 2; ++j) {
                        if (c->val == 2 && (i | j) == s) res = min(res, dfs(c->left, i) + dfs(c->right, j));
                        else if (c->val == 3 && (i & j) == s) res = min(res, dfs(c->left, i) + dfs(c->right, j));
                        else if (c->val == 4 && (i ^ j) == s) res = min(res, dfs(c->left, i) + dfs(c->right, j));
                    }
                }
            }
            dp[s][c] = res;
        }
        return dp[s][c];
    }
    int minimumFlips(TreeNode* root, bool result) {
        // 2 - or
        // 3 - and
        // 4 - xor
        // 5 - not
        return dfs(root, result);
    }
};
```
# 4.2313. äºŒå‰æ ‘ä¸­å¾—åˆ°ç»“æœéœ€è¦çš„æœ€å°ç¿»è½¬æ•°ï¼šPythonï¼šæ ‘å½¢DP
### æ–¹æ³•ï¼šæ ‘å½¢åŠ¨æ€è§„åˆ’
æœ¬é¢˜å¯ä»¥é‡‡ç”¨æ ‘ä¸Šçš„åŠ¨æ€è§„åˆ’è§£å†³ã€‚å®ç°ä¸€ä¸ªé€’å½’å‡½æ•° ${\rm traverse(node)}$ï¼Œèƒ½å¤Ÿè·å¾—ä»¥ ${\rm node}$ ä¸ºèŠ‚ç‚¹çš„å­æ ‘è¿ç®—ç»“æœä¸º ${\rm False}$ å’Œ ${\rm True}$ åˆ†åˆ«æ‰€éœ€è¦çš„æœ€å°ç¿»è½¬æ¬¡æ•°ï¼Œè‡ªåº•å‘ä¸Šåœ°é€’æ¨æ¯ä¸ªèŠ‚ç‚¹çš„è¿ç®—å€¼å˜ä¸º ${\rm False}$ å’Œ ${\rm True}$ åˆ†åˆ«æ‰€éœ€è¦çš„æœ€å°ç¿»è½¬æ¬¡æ•°ã€‚

- **å¦‚æœ ${\rm node}$ æ˜¯å¶å­ç»“ç‚¹**ã€‚å¶å­ç»“ç‚¹ä»£è¡¨ ${\rm False}$ æˆ–è€… ${\rm True}$ã€‚å¦‚æœ ${\rm node.val} = 1$ï¼Œå˜ä¸º ${\rm False}$ éœ€è¦ $1$ æ¬¡ç¿»è½¬ï¼Œå˜ä¸º ${\rm True}$ ä¸éœ€è¦ç¿»è½¬ï¼›å¦‚æœ ${\rm node.val = 0}$ï¼Œå˜ä¸º ${\rm False}$ éœ€è¦ $0$ æ¬¡ç¿»è½¬ï¼Œå˜ä¸º ${\rm True}$ éœ€è¦ $1$ æ¬¡ç¿»è½¬ã€‚ç»¼åˆè€Œè¨€è¿”å›å€¼ä¸º ${\rm (node.val, 1 - node.val)}$ï¼›

- **å¦‚æœ ${\rm node}$ æ˜¯ ${\rm not}$ æ“ä½œ**ã€‚é‚£ä¹ˆå‚ä¸è¿ç®—çš„åªä¼šæœ‰å·¦å­æ ‘å’Œå³å­æ ‘å…¶ä¸­ä¹‹ä¸€ã€‚å¦‚æœå­æ ‘å˜ä¸º ${\rm False}$ å’Œ ${\rm True}$ çš„æ¬¡æ•°åˆ†åˆ«ä¸º $x$ å’Œ $y$ï¼Œé‚£ä¹ˆç»è¿‡ ${\rm not}$ æ“ä½œä¹‹åï¼Œä¸¤è€…æƒ…å†µäº¤æ¢ï¼Œå˜ä¸º ${\rm False}$ å’Œ ${\rm True}$ çš„æ¬¡æ•°åˆ†åˆ«ä¸º $y$ å’Œ $x$ï¼›

- **å¦‚æœ ${\rm node}$ æ˜¯ ${\rm and}$ï¼Œ${\rm or}$ æˆ–è€… ${\rm xor}$ æ“ä½œ**ã€‚å¯ä»¥æšä¸¾å·¦å³å­æ ‘è¿ç®—å€¼åˆ†åˆ«ä¸º ${\rm (False, False)}$ï¼Œ${\rm (False, True)}$ï¼Œ${\rm (True, True)}$ï¼Œ${\rm (True, False)}$ çš„å››ç§ç»„åˆï¼Œè®°å·¦å³å­æ ‘å˜ä¸ºæšä¸¾å€¼çš„å˜åŒ–æ¬¡æ•°åˆ†åˆ«ä¸º $a$ å’Œ $b$ï¼Œåˆ™éœ€è¦çš„å˜åŒ–æ¬¡æ•°å°±æ˜¯å·¦å³å­æ ‘çš„å˜åŒ–æ¬¡æ•°ä¹‹å’Œ $a+b$ï¼Œä¿ç•™æ‰€æœ‰å¯èƒ½æ€§çš„æœ€å°å€¼å³å¯ã€‚

### ä»£ç å®ç°

```Python []
class Solution:
    def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:
        # é¢„å…ˆå®šä¹‰å¥½ andã€or å’Œ xor ä¸‰ç§è¿ç®—
        operations = {2: lambda x, y: x or y, 3: lambda x, y: x and y, 4: lambda x, y: x ^ y}

        def traverse(node: Optional[TreeNode]) -> Tuple[int, int]:
            # è¿”å› (false, true) = (å˜æˆ False éœ€è¦çš„ä¿®æ”¹æ¬¡æ•°, å˜æˆ True éœ€è¦çš„ä¿®æ”¹æ¬¡æ•°)
            # å¦‚æœæ˜¯å½“å‰æ˜¯ True æˆ–è€… False èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ false å’Œ true åˆ†åˆ«å–å†³äºèŠ‚ç‚¹æ˜¯å¦ä¸º True å’Œ Falseï¼Œå¦‚æœæ˜¯ï¼Œå°±éœ€è¦ä¸€æ¬¡ç¿»è½¬å˜ä¸ºç›¸åå€¼ï¼Œç»¼åˆä¸‹æ¥æ­£å¥½æ˜¯è¿”å› (node.val, 1 - node.val)ã€‚
            if node.val == 0 or node.val == 1:
                return node.val, 1 - node.val
            # å¦‚æœæ˜¯ not æ“ä½œï¼Œç›¸å½“äº True å’Œ False çš„æƒ…å†µå¯¹è°ƒ
            if node.val == 5:
                return traverse(node.left or node.right)[::-1]
            
            # true å’Œ false åˆ†åˆ«ä»£è¡¨å˜ä¸º True éœ€è¦çš„æ¬¡æ•°ã€å˜ä¸º False éœ€è¦çš„æ¬¡æ•°
            true, false = 0x3F3F3F3F, 0x3F3F3F3F
            left = traverse(node.left)
            right = traverse(node.right)
            # i å’Œ j å¯¹åº”äº† 0 å’Œ 1ï¼Œå³ False å’Œ Trueï¼Œæšä¸¾æ‰€æœ‰çš„ 0 å’Œ 1 çš„ç»„åˆï¼Œx å’Œ y å¯¹åº”äº† left[i] å’Œ right[j]ï¼Œå³å·¦å­æ ‘å˜ä¸º iï¼ˆFalse: 0, True: 1ï¼‰çš„å˜åŒ–æ¬¡æ•°å’Œå³å­æ ‘å˜ä¸º jï¼ˆFalse: 0, True: 1ï¼‰çš„å˜åŒ–æ¬¡æ•°
            for i, x in enumerate(left):
                for j, y in enumerate(right):
                    # æŒ‰ç…§ operations[node.val] å®šä¹‰çš„è¿ç®—è®¡ç®—ï¼Œå¾—åˆ° value = True æˆ–è€… False
                    value = operations[node.val](i, j)
                    # å¦‚æœ value = Trueï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹å˜ä¸º True çš„å˜åŒ–æ¬¡æ•° true ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘å˜åŒ–ä¹‹å’Œ x + y
                    if value:
                        true = min(true, x + y)
                    # å¦‚æœ value = False ç”¨ç›¸åŒçš„æ–¹å¼æ›´æ–° false
                    else:
                        false = min(false, x + y)
            # è¿”å›å½“å‰èŠ‚ç‚¹å˜ä¸º False å’Œå˜ä¸º True æ‰€éœ€è¦çš„æ¬¡æ•°
            return false, true

        # è¿”å› traverse(root) ä¸­å¯¹åº”çš„å˜æ¢åˆ° result éœ€è¦çš„æ¬¡æ•°
        return traverse(root)[result]
```
