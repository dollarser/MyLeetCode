# 1259不相交的握手
<p><strong>偶数</strong>&nbsp;个人站成一个圆，总人数为&nbsp;<code>num_people</code>&nbsp;。每个人与除自己外的一个人握手，所以总共会有&nbsp;<code>num_people / 2</code>&nbsp;次握手。</p>

<p>将握手的人之间连线，请你返回连线不会相交的握手方案数。</p>

<p>由于结果可能会很大，请你返回答案 <strong>模</strong>&nbsp;<strong><code>10^9+7</code></strong>&nbsp;后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>num_people = 2
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/5125_example_2.png" style="height: 311px; width: 651px;"></p>

<pre><strong>输入：</strong>num_people = 4
<strong>输出：</strong>2
<strong>解释：</strong>总共有两种方案，第一种方案是 [(1,2),(3,4)] ，第二种方案是 [(2,3),(4,1)] 。
</pre>

<p><strong>示例 3：</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/5125_example_3.png" style="height: 992px; width: 664px;"></p>

<pre><strong>输入：</strong>num_people = 6
<strong>输出：</strong>5
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>num_people = 8
<strong>输出：</strong>14
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>2 &lt;= num_people &lt;= 1000</code></li>
	<li><code>num_people % 2 == 0</code></li>
</ul>
































# 解题:
# 1.【儿须成名酒须醉】Python3+卡特兰数+排列组合+乘法逆元+动态规划+打表

***
### 解题思路
【儿须成名酒须醉】Python3+卡特兰数+排列组合+乘法逆元

### 代码
- 执行用时：32 ms, 在所有 Python3 提交中击败了 100.00% 的用户
- 内存消耗：15.1 MB, 在所有 Python3 提交中击败了 43.75% 的用户
- 通过测试用例：75 / 75

```python3

def produce_perm_mod(n, mod):
    # 求全排列组合数
    perm = [1] * n
    for i in range(1, n):
        perm[i] = perm[i - 1] * i
        perm[i] %= mod

    return perm

n = 500
mod = 10**9 + 7
perm = produce_perm_mod(2*n+2, mod)

class Solution:
    def numberOfWays(self, numPeople: int) -> int:
        n = numPeople // 2

        if numPeople <= 1:
            return 1

        
        # 利用乘法逆元求解组合数
        def comb(a, b):
            res = perm[a] * pow(perm[b], -1, mod) * pow(perm[a - b], -1, mod)
            return res % mod

        return (comb(2 * n, n) - comb(2 * n, n - 1)) % mod
```

### 解题思路
【儿须成名酒须醉】Python3+动态规划

### 代码
- 执行用时：52 ms, 在所有 Python3 提交中击败了 91.07% 的用户
- 内存消耗：15 MB, 在所有 Python3 提交中击败了 50.00% 的用户
- 通过测试用例：75 / 75

```python3
MOD = 10**9 + 7
dp = [1] * 501
for i in range(1, 501):
    dp[i] = sum(dp[j] * dp[i - 1 - j] for j in range(i)) % MOD


class Solution:
    def numberOfWays(self, numPeople: int) -> int:
        return dp[numPeople // 2]
```
***
### 解题思路
【儿须成名酒须醉】Python3+打表

### 代码
- 执行用时：36 ms, 在所有 Python3 提交中击败了 98.21% 的用户
- 内存消耗：15.4 MB, 在所有 Python3 提交中击败了 26.79% 的用户
- 通过测试用例：75 / 75

```python3
dp = [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 767263183, 564120378, 466266852, 482563003, 59611249, 904138301, 946367425, 352943583, 550429273, 949904131, 209635674, 475387402, 937414464, 488309750, 925890214, 459122512, 93302951, 141865378, 966114350, 869670557, 998231628, 602941373, 468488140, 436489089, 4616923, 884518775, 205311759, 837590216, 245662066, 217873312, 765348450, 265470434, 185096680, 323205961, 812467623, 961237645, 63389378, 931095477, 938406495, 709042248, 165264749, 202180493, 143994823, 895598835, 467182928, 887145589, 467932736, 337289196, 848807734, 364899808, 628322100, 685542858, 185042843, 889345934, 458247558, 316330417, 319295576, 44509913, 251538890, 88317157, 171644840, 747939002, 619955577, 784403821, 724443566, 881931175, 861543437, 697101768, 740877392, 452888603, 48028493, 826309900, 773088937, 590866122, 155536848, 391271379, 853131050, 988619170, 608234667, 577894130, 676902861, 558488487, 554042849, 795547531, 501677748, 492329396, 960317800, 507047749, 611132778, 7221034, 592126629, 687851011, 410983438, 38040815, 676476905, 974960987, 832173531, 901403157, 68253121, 849403087, 405142173, 567421139, 700794981, 110458199, 678423530, 601129776, 947322438, 673668198, 631844581, 707292517, 765756553, 493602230, 951972448, 343891011, 733300263, 300609911, 703883321, 711713562, 294171032, 869022067, 767415875, 100837272, 779370051, 301562560, 527018462, 162128243, 436370714, 605222819, 112571416, 251121713, 354441979, 516266904, 834162335, 49035108, 986437771, 668856696, 572778435, 402982067, 102954255, 728686673, 349920924, 361798437, 322682687, 217503157, 386445436, 549910994, 264105011, 256512074, 516887147, 262215304, 110194787, 840421439, 320740801, 254498198, 526458368, 339212030, 49829519, 485764535, 297470560, 749743559, 207316098, 899740102, 503364559, 619905290, 568102496, 81012050, 579499426, 475874715, 707460297, 759763069, 709796584, 52491136, 208324196, 490032817, 460439521, 73744548, 700883974, 904016574, 861399108, 816609506, 981939723, 868596491, 82249411, 700950866, 136128420, 686870898, 86700926, 590667447, 374477444, 592422379, 267048862, 515577941, 491116151, 528095125, 125611464, 19870649, 606708415, 175035255, 612754728, 420532467, 334297155, 785126250, 416582650, 430906843, 631728074, 696732868, 113566864, 808093885, 553215156, 338103882, 760986727, 193012168, 767056978, 722295098, 280916397, 248408142, 275452695, 904963875, 437377397, 922629815, 292453491, 121039181, 704296250, 157819642, 135594475, 90077624, 431284213, 645834394, 422551245, 704119401, 31578719, 217193473, 696935951, 237618823, 102342558, 677550409, 795884035, 962620544, 83909579, 704350838, 585764471, 352580526, 631255369, 868034650, 406955973, 312949408, 778573206, 355223744, 562195931, 574533989, 107590741, 586652469, 988080768, 403134459, 596410797, 467176030, 771591590, 643660388, 668663257, 703283912, 855208122, 288692791, 786926634, 685792880, 925866024, 199761629, 529121445, 419012846, 375655274, 252607483, 225893220, 610255492, 99715332, 154498555, 451575881, 27627392, 947787397, 721497296, 495623450, 701645160, 392547720, 718512182, 18714029, 64584551, 750484565, 937994287, 8094881, 68051937, 368284659, 262103974, 275600975, 418630243, 224162688, 723024629, 808219050, 646052962, 293463991, 953790398, 61316464, 313078086, 833942127, 918311629, 538122675, 616178813, 360711926, 845419172, 200472632, 880780939, 988719209, 751435126, 864805305, 869526846, 329862901, 25219831, 244138849, 903526043, 972969760, 530342463, 922606368, 647547462, 861115469, 927843991, 98606746, 760049026, 38567321, 857946379, 838873133, 67212282, 405621331, 930698133, 889694830, 834169133, 964503178, 54083453, 130671380, 957096711, 390907662, 237733031, 907841626, 850176931, 269871420, 19598613, 752102767, 202591168, 949882401, 326380828, 464107227, 64100167, 141225121, 595124466, 797874213, 205547383, 835003284, 39718154, 430962701, 604955393, 309104184, 504706850, 169546326, 738825732, 985742508, 84926816, 380258152, 851890178, 112999905, 696991831, 580242047, 257708607, 774271922, 804939519, 391989756, 697493702, 54809069, 233666672, 225524551, 982216819, 444288209, 417793307, 820653725, 856740391, 109110435, 497153305, 205073606, 454958338, 813076538, 632853148, 842257115, 184621699, 574007064, 810834988, 655864300, 102933616, 89847079, 36049131, 187152334, 606144482, 310066214, 811343037, 783965293, 446830624, 952367767, 952667707, 522244250, 776604732, 284108464, 925364088, 589831484, 819421970, 182088485, 75457593, 310079801, 964540829, 441989114, 440815720, 439196294, 571416943, 364960186, 100138764, 686854527, 323451970, 153033527, 950188076, 154369635, 773401300, 948018681, 808505912, 79649107, 431621273, 421597298, 509263162, 576929129, 876537848, 406020337, 638571138, 418091967, 910810606, 394415946, 603120023, 788858421, 772572773, 197605340, 419085930, 73498437, 647252950, 89262822, 562351124, 589803397, 263841367, 962239296, 651145998, 455845943, 671079994, 6297754, 631876461, 76469416, 469122262, 929399265, 328547989, 883289677, 899965082, 663610744, 195021619, 964380814, 174735891, 14959230, 441095159, 289799204, 418460065, 853121483, 506312642, 10887542, 320402868, 960630947, 295335557, 934840175, 849241405, 713305423, 37769293, 90381156, 584886776, 948528453, 591137401]


class Solution:
    def numberOfWays(self, numPeople: int) -> int:
        return dp[numPeople // 2]
```
# 2.c++ dp
### 解题思路
#### 1. 分割问题
![无标题.png](https://pic.leetcode-cn.com/1644023275-eRRqUI-%E6%97%A0%E6%A0%87%E9%A2%98.png)
#### 2. 我们选择最后一个人作为起点，由于所有的人不能存在相交，编号为n的人选择握手的人的编号只能为1,3,5,7,...,n-1,同时将图分为两部分，左边有j-1个，共有dp[j-1]种握手排列组合方案，右边有n-j-1个人，则他们共有dp[n-j-1]种握手方案，所以总的握手组合的方案数为dp[j-1]*dp[n-j-1].
#### 3. 状态转移方程：dp[i]+=$\Sigma^{j<n/2}_{j=0}$dp[j-1]*dp[n-j-1]
### 代码 
```cpp
class Solution {
public:
    const int mod = 1e9+7;
    int numberOfWays(int numPeople) {
        int n = numPeople;
        vector <long long> dp (n+1,1);
        for (int i = 2;i <= n;i += 2) {
            dp[i] = 0;
            for (int j = 1;j < i;j += 2) {
                dp[i] += dp[j-1]*dp[i-j-1];
                dp[i] %= mod;
            }
        }
        return dp[n];
    }
};
```
# 3.dp
1. 主要是涉及到分割的问题:
![分割.jpg](https://pic.leetcode-cn.com/5d7724dfb9318b9b76e0b35c024a1baa62fd56ce353cf746d52966bc1e987379-%E5%88%86%E5%89%B2.jpg)
2. 从1~n-1中任选一条线，将节点分割为两部分，分割两部分的排列组合之积。
3. 我们选择最后一个人作为起点，由于所有的人不能存在相交，编号为```n```的人选择握手的人的编号只能为```1,3,5,7,...,n-1```,同时将图分为两部分，左边有```j-1```个，共有```dp[j-1]```种握手排列组合方案，右边有```n-j-1```个人，则他们共有```dp[n-j-1]```种握手方案，所以总的握手组合的方案数为```dp[j-1]*dp[n-j-1]```.
4. 递推公式如下:
$$ dp[n] = \sum_{j=1}^{n/2}dp[2*j-2]*dp[n-2*j] $$

```
class Solution {
public:
    int numberOfWays(int num_people) {
        int mod = 1000000007;
        int n = num_people;
        vector<long long> dp(n+1,1);
        
        /*intial*/
        for(int i = 2; i <= n; i += 2){
            dp[i] = 0;
            for(int j = 1; j < i; j += 2){
                dp[i] = (dp[i] + (dp[j-1]*dp[i-j-1])%mod)%mod;
            }
        }
        
        return dp[n];
    }
    
};
```
# 4.Java dfs/dp
第一：

>曾经的时候，我也很疑惑，在什么情况下，两条线不会相交，现在我应该可以回答：
>
>一条线会将一个圆分成两个区间，如果另外一条线的两端都在其中一个区间中，并且不与之前的两端节点重合，那么这两条线不会相交，不然就会相交。

第二：

>当一个区间中人的个数为奇数时候，如果像题目那样每个人都与除了自己以外的一个人握手，是一定会相交的。因此我们假设所有的连线并不相交，那么就会剩下一个人，这个人不管去连谁都会导致相交，因此，我们划分区间的时候，如果该区间内人的个数为奇数，则可以返回结果0

开始第一步：

我们假设从1开始，他可以选择与自己非同奇偶的人握手，这样子两个区间的人数都是偶数，0也算偶数，分成了两个区间，其实也就是分成了两个子问题，如果使用记忆化搜索的解法，递归的结束条件就是当n==0时，返回1，当n==2时候，返回1，不然就再次划分为子问题。

记忆化搜索
```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    int mod=(int)1e9+7;
    Map<Integer,Long> map=new HashMap<>();
    public int numberOfWays(int n) {
        return (int)dfs(n);
    }
    public long dfs(int n){
        if(n==0) return 1;
        if(n==2) return 1;
        if(map.containsKey(n)) return map.get(n);
        long res=0;
        for(int i=2;i<=n;i+=2){
            res+=dfs(i-2)%mod*dfs(n-i)%mod;
            res=res%mod;
        }
        map.put(n,res);
        return res;
    }
}
```
一般情况下，记忆化搜索会没有动态规划的效率高。

下面是动态规划的写法。

```java
class Solution {
    int mod=(int)1e9+7;
    public int numberOfWays(int n) {
        long[]f=new long[n+1];
        f[0]=1;
        f[2]=1;
        for(int i=4;i<=n;i++){//i个人
            //起点是第一个人
            for(int j=2;j<=i;j+=2){//j表示第j个人
                f[i]+=f[j-2]*f[i-j]%mod;
                f[i]%=mod;
            }
        }
        return (int)f[n];
    }
}
```
