# 269ç«æ˜Ÿè¯å…¸
<p>ç°æœ‰ä¸€ç§ä½¿ç”¨è‹±è¯­å­—æ¯çš„ç«æ˜Ÿè¯­è¨€ï¼Œè¿™é—¨è¯­è¨€çš„å­—æ¯é¡ºåºä¸è‹±è¯­é¡ºåºä¸åŒã€‚</p>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ <code>words</code> ï¼Œä½œä¸ºè¿™é—¨è¯­è¨€çš„è¯å…¸ï¼Œ<code>words</code> ä¸­çš„å­—ç¬¦ä¸²å·²ç» <strong>æŒ‰è¿™é—¨æ–°è¯­è¨€çš„å­—æ¯é¡ºåºè¿›è¡Œäº†æ’åº</strong> ã€‚</p>

<p>è¯·ä½ æ ¹æ®è¯¥è¯å…¸è¿˜åŸå‡ºæ­¤è¯­è¨€ä¸­å·²çŸ¥çš„å­—æ¯é¡ºåºï¼Œå¹¶ <strong>æŒ‰å­—æ¯é€’å¢é¡ºåº</strong> æ’åˆ—ã€‚è‹¥ä¸å­˜åœ¨åˆæ³•å­—æ¯é¡ºåºï¼Œè¿”å› <code>""</code> ã€‚è‹¥å­˜åœ¨å¤šç§å¯èƒ½çš„åˆæ³•å­—æ¯é¡ºåºï¼Œè¿”å›å…¶ä¸­ <strong>ä»»æ„ä¸€ç§</strong> é¡ºåºå³å¯ã€‚</p>

<p>å­—ç¬¦ä¸² <code>s</code> <strong>å­—å…¸é¡ºåºå°äº</strong> å­—ç¬¦ä¸² <code>t</code> æœ‰ä¸¤ç§æƒ…å†µï¼š</p>

<ul>
	<li>åœ¨ç¬¬ä¸€ä¸ªä¸åŒå­—æ¯å¤„ï¼Œå¦‚æœ <code>s</code> ä¸­çš„å­—æ¯åœ¨è¿™é—¨å¤–æ˜Ÿè¯­è¨€çš„å­—æ¯é¡ºåºä¸­ä½äº <code>t</code> ä¸­å­—æ¯ä¹‹å‰ï¼Œé‚£ä¹ˆÂ <code>s</code> çš„å­—å…¸é¡ºåºå°äº <code>t</code> ã€‚</li>
	<li>å¦‚æœå‰é¢ <code>min(s.length, t.length)</code> å­—æ¯éƒ½ç›¸åŒï¼Œé‚£ä¹ˆ <code>s.length < t.length</code> æ—¶ï¼Œ<code>s</code> çš„å­—å…¸é¡ºåºä¹Ÿå°äº <code>t</code> ã€‚</li>
</ul>

<p>Â </p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["wrt","wrf","er","ett","rftt"]
<strong>è¾“å‡ºï¼š</strong>"wertf"
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["z","x"]
<strong>è¾“å‡ºï¼š</strong>"zx"
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["z","x","z"]
<strong>è¾“å‡ºï¼š</strong>""
<strong>è§£é‡Šï¼š</strong>ä¸å­˜åœ¨åˆæ³•å­—æ¯é¡ºåºï¼Œå› æ­¤è¿”å› <code>"" ã€‚</code>
</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>1 <= words.length <= 100</code></li>
	<li><code>1 <= words[i].length <= 100</code></li>
	<li><code>words[i]</code> ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
</ul>
































# è§£é¢˜:
# 1.ç«æ˜Ÿè¯å…¸
#### å‰è¨€

è¿™é“é¢˜æ˜¯æ‹“æ‰‘æ’åºé—®é¢˜ã€‚ç«æ˜Ÿè¯å…¸ä¸­çš„å­—æ¯å’Œå­—æ¯é¡ºåºå¯ä»¥çœ‹æˆæœ‰å‘å›¾ï¼Œå­—å…¸é¡ºåºå³ä¸ºæ‰€æœ‰å­—æ¯çš„ä¸€ç§æ’åˆ—ï¼Œæ»¡è¶³æ¯ä¸€æ¡æœ‰å‘è¾¹çš„èµ·ç‚¹å­—æ¯å’Œç»ˆç‚¹å­—æ¯çš„é¡ºåºéƒ½å’Œè¿™ä¸¤ä¸ªå­—æ¯åœ¨æ’åˆ—ä¸­çš„é¡ºåºç›¸åŒï¼Œè¯¥æ’åˆ—å³ä¸ºæœ‰å‘å›¾çš„æ‹“æ‰‘æ’åºã€‚

åªæœ‰å½“æœ‰å‘å›¾ä¸­æ— ç¯æ—¶ï¼Œæ‰æœ‰æ‹“æ‰‘æ’åºï¼Œä¸”æ‹“æ‰‘æ’åºå¯èƒ½ä¸æ­¢ä¸€ç§ã€‚å¦‚æœæœ‰å‘å›¾ä¸­æœ‰ç¯ï¼Œåˆ™ç¯å†…çš„å­—æ¯ä¸å­˜åœ¨ç¬¦åˆè¦æ±‚çš„æ’åˆ—ï¼Œå› æ­¤æ²¡æœ‰æ‹“æ‰‘æ’åºã€‚

ä½¿ç”¨æ‹“æ‰‘æ’åºæ±‚è§£æ—¶ï¼Œå°†ç«æ˜Ÿè¯å…¸ä¸­çš„æ¯ä¸ªå­—æ¯çœ‹æˆä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å­—æ¯ä¹‹é—´çš„é¡ºåºå…³ç³»çœ‹æˆæœ‰å‘è¾¹ã€‚å¯¹äºç«æ˜Ÿè¯å…¸ä¸­çš„ä¸¤ä¸ªç›¸é‚»å•è¯ï¼ŒåŒæ—¶ä»å·¦åˆ°å³éå†ï¼Œå½“é‡åˆ°ç¬¬ä¸€ä¸ªä¸ç›¸åŒçš„å­—æ¯æ—¶ï¼Œè¯¥ä½ç½®çš„ä¸¤ä¸ªå­—æ¯ä¹‹é—´å³å­˜åœ¨é¡ºåºå…³ç³»ã€‚

ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸å­˜åœ¨åˆæ³•å­—æ¯é¡ºåºï¼š

- å­—æ¯ä¹‹é—´çš„é¡ºåºå…³ç³»å­˜åœ¨ç”±è‡³å°‘ $2$ ä¸ªå­—æ¯ç»„æˆçš„ç¯ï¼Œä¾‹å¦‚ $\textit{words} = [\text{``a"}, \text{``b"}, \text{``a"}]$ï¼›

- ç›¸é‚»ä¸¤ä¸ªå•è¯æ»¡è¶³åé¢çš„å•è¯æ˜¯å‰é¢çš„å•è¯çš„å‰ç¼€ï¼Œä¸”åé¢çš„å•è¯çš„é•¿åº¦å°äºå‰é¢çš„å•è¯çš„é•¿åº¦ï¼Œä¾‹å¦‚ $\textit{words} = [\text{``ab"}, \text{``a"}]$ã€‚

å…¶ä½™æƒ…å†µä¸‹éƒ½å­˜åœ¨åˆæ³•å­—æ¯é¡ºåºï¼Œå¯ä»¥ä½¿ç”¨æ‹“æ‰‘æ’åºå¾—åˆ°å­—å…¸é¡ºåºã€‚

æ‹“æ‰‘æ’åºå¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æˆ–å¹¿åº¦ä¼˜å…ˆæœç´¢å®ç°ï¼Œä»¥ä¸‹åˆ†åˆ«ä»‹ç»ä¸¤ç§å®ç°æ–¹æ³•ã€‚

#### æ–¹æ³•ä¸€ï¼šæ‹“æ‰‘æ’åº + æ·±åº¦ä¼˜å…ˆæœç´¢

ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢å®ç°æ‹“æ‰‘æ’åºçš„æ€»ä½“æ€æƒ³æ˜¯ï¼šå¯¹äºä¸€ä¸ªç‰¹å®šèŠ‚ç‚¹ï¼Œå¦‚æœè¯¥èŠ‚ç‚¹çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹éƒ½å·²ç»æœç´¢å®Œæˆï¼Œåˆ™è¯¥èŠ‚ç‚¹ä¹Ÿä¼šå˜æˆå·²ç»æœç´¢å®Œæˆçš„èŠ‚ç‚¹ï¼Œåœ¨æ‹“æ‰‘æ’åºä¸­ï¼Œè¯¥èŠ‚ç‚¹ä½äºå…¶æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹çš„å‰é¢ã€‚ä¸€ä¸ªèŠ‚ç‚¹çš„ç›¸é‚»èŠ‚ç‚¹æŒ‡çš„æ˜¯ä»è¯¥èŠ‚ç‚¹å‡ºå‘é€šè¿‡ä¸€æ¡æœ‰å‘è¾¹å¯ä»¥åˆ°è¾¾çš„èŠ‚ç‚¹ã€‚

ç”±äºæ‹“æ‰‘æ’åºçš„é¡ºåºå’Œæœç´¢å®Œæˆçš„é¡ºåºç›¸åï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ä¸€ä¸ªæ ˆå­˜å‚¨æ‰€æœ‰å·²ç»æœç´¢å®Œæˆçš„èŠ‚ç‚¹ã€‚æ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­éœ€è¦ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€å¯èƒ½æœ‰ä¸‰ç§æƒ…å†µï¼šã€Œæœªè®¿é—®ã€ã€ã€Œè®¿é—®ä¸­ã€å’Œã€Œå·²è®¿é—®ã€ã€‚åˆå§‹æ—¶ï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„çŠ¶æ€éƒ½æ˜¯ã€Œæœªè®¿é—®ã€ã€‚

æ¯ä¸€è½®æœç´¢æ—¶ï¼Œä»»æ„é€‰å–ä¸€ä¸ªã€Œæœªè®¿é—®ã€çš„èŠ‚ç‚¹ $u$ï¼Œä»èŠ‚ç‚¹ $u$ å¼€å§‹æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚å°†èŠ‚ç‚¹ $u$ çš„çŠ¶æ€æ›´æ–°ä¸ºã€Œè®¿é—®ä¸­ã€ï¼Œå¯¹äºæ¯ä¸ªä¸èŠ‚ç‚¹ $u$ ç›¸é‚»çš„èŠ‚ç‚¹ $v$ï¼Œåˆ¤æ–­èŠ‚ç‚¹ $v$ çš„çŠ¶æ€ï¼Œæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š

- å¦‚æœèŠ‚ç‚¹ $v$ çš„çŠ¶æ€æ˜¯ã€Œæœªè®¿é—®ã€ï¼Œåˆ™ç»§ç»­æœç´¢èŠ‚ç‚¹ $v$ï¼›

- å¦‚æœèŠ‚ç‚¹ $v$ çš„çŠ¶æ€æ˜¯ã€Œè®¿é—®ä¸­ã€ï¼Œåˆ™æ‰¾åˆ°æœ‰å‘å›¾ä¸­çš„ç¯ï¼Œå› æ­¤ä¸å­˜åœ¨æ‹“æ‰‘æ’åºï¼›

- å¦‚æœèŠ‚ç‚¹ $v$ çš„çŠ¶æ€æ˜¯ã€Œå·²è®¿é—®ã€ï¼Œåˆ™èŠ‚ç‚¹ $v$ å·²ç»æœç´¢å®Œæˆå¹¶å…¥æ ˆï¼ŒèŠ‚ç‚¹ $u$ å°šæœªå…¥æ ˆï¼Œå› æ­¤èŠ‚ç‚¹ $u$ çš„æ‹“æ‰‘é¡ºåºä¸€å®šåœ¨èŠ‚ç‚¹ $v$ çš„å‰é¢ï¼Œä¸éœ€è¦æ‰§è¡Œä»»ä½•æ“ä½œã€‚

å½“èŠ‚ç‚¹ $u$ çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹çš„çŠ¶æ€éƒ½æ˜¯ã€Œå·²è®¿é—®ã€æ—¶ï¼Œå°†èŠ‚ç‚¹ $u$ çš„çŠ¶æ€æ›´æ–°ä¸ºã€Œå·²è®¿é—®ã€ï¼Œå¹¶å°†èŠ‚ç‚¹ $u$ å…¥æ ˆã€‚

å½“æ‰€æœ‰èŠ‚ç‚¹éƒ½è®¿é—®ç»“æŸä¹‹åï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°æœ‰å‘å›¾ä¸­çš„ç¯ï¼Œåˆ™å­˜åœ¨æ‹“æ‰‘æ’åºï¼Œæ‰€æœ‰èŠ‚ç‚¹ä»æ ˆé¡¶åˆ°æ ˆåº•çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºã€‚

å®ç°æ–¹é¢ï¼Œç”±äºæ¯ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªå­—æ¯ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å­—ç¬¦æ•°ç»„ä»£æ›¿æ ˆï¼Œå½“èŠ‚ç‚¹å…¥æ ˆæ—¶ï¼Œåœ¨å­—ç¬¦æ•°ç»„ä¸­æŒ‰ç…§ä»åå¾€å‰çš„é¡ºåºä¾æ¬¡å¡«å…¥æ¯ä¸ªå­—æ¯ã€‚å½“æ‰€æœ‰èŠ‚ç‚¹éƒ½è®¿é—®ç»“æŸä¹‹åï¼Œå°†å­—ç¬¦æ•°ç»„è½¬æˆå­—ç¬¦ä¸²ï¼Œå³ä¸ºå­—å…¸é¡ºåºã€‚

<![ppt0](https://assets.leetcode-cn.com/solution-static/269/0.PNG),![ppt1](https://assets.leetcode-cn.com/solution-static/269/1.PNG),![ppt2](https://assets.leetcode-cn.com/solution-static/269/2.PNG),![ppt3](https://assets.leetcode-cn.com/solution-static/269/3.PNG),![ppt4](https://assets.leetcode-cn.com/solution-static/269/4.PNG),![ppt5](https://assets.leetcode-cn.com/solution-static/269/5.PNG),![ppt6](https://assets.leetcode-cn.com/solution-static/269/6.PNG),![ppt7](https://assets.leetcode-cn.com/solution-static/269/7.PNG),![ppt8](https://assets.leetcode-cn.com/solution-static/269/8.PNG),![ppt9](https://assets.leetcode-cn.com/solution-static/269/9.PNG),![ppt10](https://assets.leetcode-cn.com/solution-static/269/10.PNG)>

```Python [sol1-Python3]
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        g = {}
        for c in words[0]:
            g[c] = []
        for s, t in pairwise(words):
            for c in t:
                g.setdefault(c, [])
            for u, v in zip(s, t):
                if u != v:
                    g[u].append(v)
                    break
            else:
                if len(s) > len(t):
                    return ""

        VISITING, VISITED = 1, 2
        states = {}
        order = []
        def dfs(u: str) -> bool:
            states[u] = VISITING
            for v in g[u]:
                if v not in states:
                    if not dfs(v):
                        return False
                elif states[v] == VISITING:
                    return False
            order.append(u)
            states[u] = VISITED
            return True

        return ''.join(reversed(order)) if all(dfs(u) for u in g if u not in states) else ""
```

```Java [sol1-Java]
class Solution {
    static final int VISITING = 1, VISITED = 2;
    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();
    Map<Character, Integer> states = new HashMap<Character, Integer>();
    boolean valid = true;
    char[] order;
    int index;

    public String alienOrder(String[] words) {
        int length = words.length;
        for (String word : words) {
            int wordLength = word.length();
            for (int j = 0; j < wordLength; j++) {
                char c = word.charAt(j);
                edges.putIfAbsent(c, new ArrayList<Character>());
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        order = new char[edges.size()];
        index = edges.size() - 1;
        Set<Character> letterSet = edges.keySet();
        for (char u : letterSet) {
            if (!states.containsKey(u)) {
                dfs(u);
            }
        }
        if (!valid) {
            return "";
        }
        return new String(order);
    }

    public void addEdge(String before, String after) {
        int length1 = before.length(), length2 = after.length();
        int length = Math.min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before.charAt(index), c2 = after.charAt(index);
            if (c1 != c2) {
                edges.get(c1).add(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    public void dfs(char u) {
        states.put(u, VISITING);
        List<Character> adjacent = edges.get(u);
        for (char v : adjacent) {
            if (!states.containsKey(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states.get(v) == VISITING) {
                valid = false;
                return;
            }
        }
        states.put(u, VISITED);
        order[index] = u;
        index--;
    }
}
```

```C# [sol1-C#]
public class Solution {
    const int VISITING = 1, VISITED = 2;
    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();
    Dictionary<char, int> states = new Dictionary<char, int>();
    bool valid = true;
    char[] order;
    int index;

    public string AlienOrder(string[] words) {
        int length = words.Length;
        foreach (string word in words) {
            foreach (char c in word) {
                if (!edges.ContainsKey(c)) {
                    edges.Add(c, new List<char>());
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            AddEdge(words[i - 1], words[i]);
        }
        order = new char[edges.Count];
        index = edges.Count - 1;
        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;
        foreach (char u in letterSet) {
            if (!states.ContainsKey(u)) {
                DFS(u);
            }
        }
        if (!valid) {
            return "";
        }
        return new string(order);
    }

    public void AddEdge(string before, string after) {
        int length1 = before.Length, length2 = after.Length;
        int length = Math.Min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].Add(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    public void DFS(char u) {
        states.Add(u, VISITING);
        IList<char> adjacent = edges[u];
        foreach (char v in adjacent) {
            if (!states.ContainsKey(v)) {
                DFS(v);
                if (!valid) {
                    return;
                }
            } else if (states[v] == VISITING) {
                valid = false;
                return;
            }
        }
        states[u] = VISITED;
        order[index] = u;
        index--;
    }
}
```

```C++ [sol1-C++]
class Solution {
public:
    const int VISITING = 1, VISITED = 2;
    unordered_map<char, vector<char>> edges;
    unordered_map<char, int> states;
    bool valid = true;
    string order;
    int index;

    string alienOrder(vector<string>& words) {
        int length = words.size();
        for (string & word : words) {
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                char c = word[j];
                if (!edges.count(c)) {
                    edges[c] = vector<char>();
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        order = string(edges.size(), ' ');
        index = edges.size() - 1;
        for (auto [u, _] : edges) {
            if (!states.count(u)) {
                dfs(u);
            }
        }
        if (!valid) {
            return "";
        }
        return order;
    }

    void addEdge(string before, string after) {
        int length1 = before.size(), length2 = after.size();
        int length = min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].emplace_back(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    void dfs(char u) {
        states[u] = VISITING;
        for (char v : edges[u]) {
            if (!states.count(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states[v] == VISITING) {
                valid = false;
                return;
            }
        }
        states[u] = VISITED;
        order[index] = u;
        index--;
    }
};
```

```C [sol1-C]
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define VISITING 1
#define VISITED 2

void addEdge(const char *before, const char *after, int **edges, bool *valid) {
    int length1 = strlen(before), length2 = strlen(after);
    int length = MIN(length1, length2);
    int index = 0;
    while (index < length) {
        char c1 = before[index], c2 = after[index];
        if (c1 != c2) {
            edges[c1 - 'a'][c2 - 'a'] = 1;
            break;
        }
        index++;
    }
    if (index == length && length1 > length2) {
        *valid = false;
    }
}

void dfs(int u, char *order, int *index, int **edges, int *states, bool *valid) {
    states[u] = VISITING;
    if (edges[u]) {
        for (int i = 0; i < 26; i++) {
            if (edges[u][i]) {
                if (!states[i]) {
                    dfs(i, order, index, edges, states, valid);
                    if (!valid) {
                        return;
                    }
                } else if (states[i] == VISITING) {
                    *valid = false;
                    return;
                }
            }
        }
    }
    states[u] = VISITED;
    order[*index] = 'a' + u;
    (*index)--;
}

char * alienOrder(char ** words, int wordsSize) {
    int edgesSize = 0;
    int *edges[26];
    int states[26];
    bool valid = true;
    for (int i = 0; i < 26; i++) {
        edges[i] = NULL;
    }
    memset(states, 0, sizeof(states));
    for (int i = 0; i < wordsSize; i++) {
        int wordLength = strlen(words[i]);
        for (int j = 0; j < wordLength; j++) {
            char c = words[i][j];
            if (!edges[c - 'a']) {
                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);
                memset(edges[c - 'a'], 0, sizeof(int) * 26);
                edgesSize++;
            }
        }
    }
    for (int i = 1; i < wordsSize && valid; i++) {
        addEdge(words[i - 1], words[i], edges, &valid);
    }
    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));
    memset(order, ' ', sizeof(char) * edgesSize);
    order[edgesSize] = '\0';
    int index = edgesSize - 1;
    for (int i = 0; i < 26; i++) {
        if (edges[i] && !states[i]) {
            dfs(i, order, &index, edges, states, &valid);
        }
    }
    for (int i = 0; i < 26; i++) {
        if (edges[i]) {
            free(edges[i]);
        }
    }
    if (!valid) {
        order[0] = '\0';
    }
    return order;
}
```

```JavaScript [sol1-JavaScript]
var alienOrder = function(words) {
    const VISITING = 1, VISITED = 2;
    let valid = true;
    const edges = new Map();
    const states = new Map();
    const length = words.length;
    for (const word of words) {
        const wordLength = word.length;
        for (let j = 0; j < wordLength; j++) {
            const c = word[j];
            if (!edges.has(c)) {
                edges.set(c, []);
            }
        }
    }

    const addEdge = (before, after) => {
        const length1 = before.length, length2 = after.length;
        const length = Math.min(length1, length2);
        let index = 0;
        while (index < length) {
            const c1 = before[index], c2 = after[index];
            if (c1 !== c2) {
                edges.get(c1).push(c2);
                break;
            }
            index++;
        }
        if (index === length && length1 > length2) {
            valid = false;
        }
    }

    const dfs = (u) => {
        states.set(u, VISITING);
        const adjacent = edges.get(u);
        for (const v of adjacent) {
            if (!states.has(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states.get(v) === VISITING) {
                valid = false;
                return;
            }
        }
        states.set(u, VISITED);
        order[index] = u;
        index--;
    }

    for (let i = 1; i < length && valid; i++) {
        addEdge(words[i - 1], words[i]);
    }
    const order = new Array(edges.size).fill(0);
    let index = edges.size - 1;
    const letterSet = edges.keys();
    for (const u of letterSet) {
        if (!states.has(u)) {
            dfs(u);
        }
    }
    if (!valid) {
        return "";
    }
    return order.join('');

    
};
```

```go [sol1-Golang]
func alienOrder(words []string) string {
    g := map[byte][]byte{}
    for _, c := range words[0] {
        g[byte(c)] = nil
    }
next:
    for i := 1; i < len(words); i++ {
        s, t := words[i-1], words[i]
        for _, c := range t {
            g[byte(c)] = g[byte(c)]
        }
        for j := 0; j < len(s) && j < len(t); j++ {
            if s[j] != t[j] {
                g[s[j]] = append(g[s[j]], t[j])
                continue next
            }
        }
        if len(s) > len(t) {
            return ""
        }
    }

    const visiting, visited = 1, 2
    order := make([]byte, len(g))
    i := len(g) - 1
    state := map[byte]int{}
    var dfs func(u byte) bool
    dfs = func(u byte) bool {
        state[u] = visiting
        for _, v := range g[u] {
            if state[v] == 0 {
                if !dfs(v) {
                    return false
                }
            } else if state[v] == visiting {
                return false
            }
        }
        order[i] = u
        i--
        state[u] = visited
        return true
    }
    for u := range g {
        if state[u] == 0 && !dfs(u) {
            return ""
        }
    }
    return string(order)
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \times L + |\Sigma|)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{words}$ çš„é•¿åº¦ï¼Œå³å­—å…¸ä¸­çš„å•è¯æ•°ï¼Œ$L$ æ˜¯å­—å…¸ä¸­çš„å¹³å‡å•è¯é•¿åº¦ï¼Œ$\Sigma$ æ˜¯å­—å…¸ä¸­çš„å­—æ¯é›†åˆã€‚éå†å­—å…¸æ„é€ æœ‰å‘å›¾éœ€è¦ $O(n \times L)$ çš„æ—¶é—´ï¼Œç”±äºæœ‰å‘å›¾åŒ…å«æœ€å¤š $n - 1$ æ¡è¾¹å’Œ $|\Sigma|$ ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤æ·±åº¦ä¼˜å…ˆæœç´¢éœ€è¦ $O(n + |\Sigma|)$ çš„æ—¶é—´ï¼Œæ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \times L + n + |\Sigma|) = O(n \times L + |\Sigma|)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n + |\Sigma|)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{words}$ çš„é•¿åº¦ï¼Œå³å­—å…¸ä¸­çš„å•è¯æ•°ï¼Œ$\Sigma$ æ˜¯å­—å…¸ä¸­çš„å­—æ¯é›†åˆã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºå­˜å‚¨æœ‰å‘å›¾éœ€è¦çš„ç©ºé—´ï¼Œæœ‰å‘å›¾åŒ…å«æœ€å¤š $n - 1$ æ¡è¾¹å’Œ $|\Sigma|$ ä¸ªèŠ‚ç‚¹ã€‚

#### æ–¹æ³•äºŒï¼šæ‹“æ‰‘æ’åº + å¹¿åº¦ä¼˜å…ˆæœç´¢

æ–¹æ³•ä¸€ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢å®ç°æ‹“æ‰‘æ’åºï¼Œæ ¹æ®æ¯ä¸ªèŠ‚ç‚¹æœç´¢å®Œæˆçš„é¡ºåºåå‘å¾—åˆ°æ‹“æ‰‘æ’åºã€‚ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢å®ç°æ‹“æ‰‘æ’åºï¼Œåˆ™å¯ä»¥æ­£å‘å¾—åˆ°æ‹“æ‰‘æ’åºã€‚

é¦–å…ˆè®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ï¼Œåªæœ‰å…¥åº¦ä¸º $0$ çš„èŠ‚ç‚¹å¯èƒ½æ˜¯æ‹“æ‰‘æ’åºä¸­æœ€å‰é¢çš„èŠ‚ç‚¹ã€‚å½“ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥æ‹“æ‰‘æ’åºä¹‹åï¼Œè¯¥èŠ‚ç‚¹çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦éƒ½å‡ $1$ï¼Œè¡¨ç¤ºç›¸é‚»èŠ‚ç‚¹å°‘äº†ä¸€æ¡å…¥è¾¹ã€‚å½“ä¸€ä¸ªèŠ‚ç‚¹çš„å…¥åº¦å˜æˆ $0$ï¼Œåˆ™è¯¥èŠ‚ç‚¹å‰é¢çš„èŠ‚ç‚¹éƒ½å·²ç»åŠ å…¥æ‹“æ‰‘æ’åºï¼Œè¯¥èŠ‚ç‚¹ä¹Ÿå¯ä»¥åŠ å…¥æ‹“æ‰‘æ’åºã€‚

å…·ä½“åšæ³•æ˜¯ï¼Œä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨å¯ä»¥åŠ å…¥æ‹“æ‰‘æ’åºçš„èŠ‚ç‚¹ï¼Œåˆå§‹æ—¶å°†æ‰€æœ‰å…¥åº¦ä¸º $0$ çš„èŠ‚ç‚¹å…¥é˜Ÿåˆ—ã€‚æ¯æ¬¡å°†ä¸€ä¸ªèŠ‚ç‚¹å‡ºé˜Ÿåˆ—å¹¶åŠ å…¥æ‹“æ‰‘æ’åºä¸­ï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦éƒ½å‡ $1$ï¼Œå¦‚æœä¸€ä¸ªç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦å˜æˆ $0$ï¼Œåˆ™å°†è¯¥ç›¸é‚»èŠ‚ç‚¹å…¥é˜Ÿåˆ—ã€‚é‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢ç»“æŸã€‚

å¦‚æœæœ‰å‘å›¾ä¸­æ— ç¯ï¼Œåˆ™æ¯ä¸ªèŠ‚ç‚¹éƒ½å°†åŠ å…¥æ‹“æ‰‘æ’åºï¼Œå› æ­¤æ‹“æ‰‘æ’åºçš„é•¿åº¦ç­‰äºå­—å…¸ä¸­çš„å­—æ¯ä¸ªæ•°ã€‚å¦‚æœæœ‰å‘å›¾ä¸­æœ‰ç¯ï¼Œåˆ™ç¯ä¸­çš„èŠ‚ç‚¹ä¸ä¼šåŠ å…¥æ‹“æ‰‘æ’åºï¼Œå› æ­¤æ‹“æ‰‘æ’åºçš„é•¿åº¦å°äºå­—å…¸ä¸­çš„å­—æ¯ä¸ªæ•°ã€‚å¹¿åº¦ä¼˜å…ˆæœç´¢ç»“æŸæ—¶ï¼Œåˆ¤æ–­æ‹“æ‰‘æ’åºçš„é•¿åº¦æ˜¯å¦ç­‰äºå­—å…¸ä¸­çš„å­—æ¯ä¸ªæ•°ï¼Œå³å¯åˆ¤æ–­æœ‰å‘å›¾ä¸­æ˜¯å¦æœ‰ç¯ã€‚

- å¦‚æœæ‹“æ‰‘æ’åºçš„é•¿åº¦ç­‰äºå­—å…¸ä¸­çš„å­—æ¯ä¸ªæ•°ï¼Œåˆ™æ‹“æ‰‘æ’åºåŒ…å«å­—å…¸ä¸­çš„æ‰€æœ‰å­—æ¯ï¼Œè¿”å›æ‹“æ‰‘æ’åºï¼›

- å¦‚æœæ‹“æ‰‘æ’åºçš„é•¿åº¦å°äºå­—å…¸ä¸­çš„å­—æ¯ä¸ªæ•°ï¼Œåˆ™æœ‰å‘å›¾ä¸­æœ‰ç¯ï¼Œä¸å­˜åœ¨æ‹“æ‰‘æ’åºã€‚

<![p1](https://assets.leetcode-cn.com/solution-static/269/p1.PNG),![p2](https://assets.leetcode-cn.com/solution-static/269/p2.PNG),![p3](https://assets.leetcode-cn.com/solution-static/269/p3.PNG),![p4](https://assets.leetcode-cn.com/solution-static/269/p4.PNG),![p5](https://assets.leetcode-cn.com/solution-static/269/p5.PNG),![p6](https://assets.leetcode-cn.com/solution-static/269/p6.PNG),![p7](https://assets.leetcode-cn.com/solution-static/269/p7.PNG),![p8](https://assets.leetcode-cn.com/solution-static/269/p8.PNG),![p9](https://assets.leetcode-cn.com/solution-static/269/p9.PNG),![p10](https://assets.leetcode-cn.com/solution-static/269/p10.PNG),![p11](https://assets.leetcode-cn.com/solution-static/269/p11.PNG),![p12](https://assets.leetcode-cn.com/solution-static/269/p12.PNG)>

```Python [sol2-Python3]
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        g = defaultdict(list)
        inDeg = {c: 0 for c in words[0]}
        for s, t in pairwise(words):
            for c in t:
                inDeg.setdefault(c, 0)
            for u, v in zip(s, t):
                if u != v:
                    g[u].append(v)
                    inDeg[v] += 1
                    break
            else:
                if len(s) > len(t):
                    return ""

        q = [u for u, d in inDeg.items() if d == 0]
        for u in q:
            for v in g[u]:
                inDeg[v] -= 1
                if inDeg[v] == 0:
                    q.append(v)
        return ''.join(q) if len(q) == len(inDeg) else ""
```

```Java [sol2-Java]
class Solution {
    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();
    Map<Character, Integer> indegrees = new HashMap<Character, Integer>();
    boolean valid = true;

    public String alienOrder(String[] words) {
        int length = words.length;
        for (String word : words) {
            int wordLength = word.length();
            for (int j = 0; j < wordLength; j++) {
                char c = word.charAt(j);
                edges.putIfAbsent(c, new ArrayList<Character>());
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        Queue<Character> queue = new ArrayDeque<Character>();
        Set<Character> letterSet = edges.keySet();
        for (char u : letterSet) {
            if (!indegrees.containsKey(u)) {
                queue.offer(u);
            }
        }
        StringBuffer order = new StringBuffer();
        while (!queue.isEmpty()) {
            char u = queue.poll();
            order.append(u);
            List<Character> adjacent = edges.get(u);
            for (char v : adjacent) {
                indegrees.put(v, indegrees.get(v) - 1);
                if (indegrees.get(v) == 0) {
                    queue.offer(v);
                }
            }
        }
        return order.length() == edges.size() ? order.toString() : "";
    }

    public void addEdge(String before, String after) {
        int length1 = before.length(), length2 = after.length();
        int length = Math.min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before.charAt(index), c2 = after.charAt(index);
            if (c1 != c2) {
                edges.get(c1).add(c2);
                indegrees.put(c2, indegrees.getOrDefault(c2, 0) + 1);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
}
```

```C# [sol2-C#]
public class Solution {
    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();
    Dictionary<char, int> indegrees = new Dictionary<char, int>();
    bool valid = true;

    public string AlienOrder(string[] words) {
        int length = words.Length;
        foreach (string word in words) {
            foreach (char c in word) {
                if (!edges.ContainsKey(c)) {
                    edges.Add(c, new List<char>());
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            AddEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        Queue<char> queue = new Queue<char>();
        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;
        foreach (char u in letterSet) {
            if (!indegrees.ContainsKey(u)) {
                queue.Enqueue(u);
            }
        }
        StringBuilder order = new StringBuilder();
        while (queue.Count > 0) {
            char u = queue.Dequeue();
            order.Append(u);
            IList<char> adjacent = edges[u];
            foreach (char v in adjacent) {
                indegrees[v]--;
                if (indegrees[v] == 0) {
                    queue.Enqueue(v);
                }
            }
        }
        return order.Length == edges.Count ? order.ToString() : "";
    }

    public void AddEdge(string before, string after) {
        int length1 = before.Length, length2 = after.Length;
        int length = Math.Min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].Add(c2);
                if (!indegrees.ContainsKey(c2)) {
                    indegrees.Add(c2, 0);
                }
                indegrees[c2]++;
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
}
```

```C++ [sol2-C++]
class Solution {
public:
    unordered_map<char, vector<char>> edges;
    unordered_map<char, int> indegrees;
    bool valid = true;

    string alienOrder(vector<string>& words) {
        int length = words.size();
        for (auto word : words) {
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                char c = word[j];
                if (!edges.count(c)) {
                    edges[c] = vector<char>();
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        queue<char> qu;
        for (auto [u, _] : edges) {
            if (!indegrees.count(u)) {
                qu.emplace(u);
            }
        }
        string order;
        while (!qu.empty()) {
            char u = qu.front();
            qu.pop();
            order.push_back(u);
            for (char v : edges[u]) {
                indegrees[v]--;
                if (indegrees[v] == 0) {
                    qu.emplace(v);
                }
            }
        }
        return order.size() == edges.size() ? order : "";
    }

    void addEdge(string before, string after) {
        int length1 = before.size(), length2 = after.size();
        int length = min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].emplace_back(c2);
                indegrees[c2] += 1;
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
};
```

```C [sol2-C]
#define MIN(a, b) ((a) < (b) ? (a) : (b))

void addEdge(const char *before, const char *after, int **edges, int *indegrees, bool *valid) {
    int length1 = strlen(before), length2 = strlen(after);
    int length = MIN(length1, length2);
    int index = 0;
    while (index < length) {
        char c1 = before[index], c2 = after[index];
        if (c1 != c2 ) {
            if (edges[c1 - 'a'][c2 - 'a'] == 0) {
                edges[c1 - 'a'][c2 - 'a'] = 1;
                indegrees[c2 - 'a']++;
            }
            break;
        }
        index++;
    }
    if (index == length && length1 > length2) {
        *valid = false;
    }
}

char * alienOrder(char ** words, int wordsSize) {
    int edgesSize = 0;
    int *edges[26];
    int indegrees[26];
    bool valid = true;
    memset(indegrees, 0, sizeof(indegrees));
    for (int i = 0; i < 26; i++) {
        edges[i] = NULL;
    }
    for (int i = 0; i < wordsSize; i++) {
        int wordLength = strlen(words[i]);
        for (int j = 0; j < wordLength; j++) {
            char c = words[i][j];
            if (!edges[c - 'a']) {
                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);
                memset(edges[c - 'a'], 0, sizeof(int) * 26);
                edgesSize++;
            }
        }
    }
    for (int i = 1; i < wordsSize && valid; i++) {
        addEdge(words[i - 1], words[i], edges, indegrees, &valid);
    }
    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));
    order[edgesSize] = '\0';
    int * queue = (int *)malloc(sizeof(int) * 26);
    int head = 0;
    int tail = 0;
    int pos = 0;
    for (int i = 0; i < 26; i++) {
        if (edges[i] && !indegrees[i]) {
            queue[tail++] = i;
        }
    }
    while (head != tail) {
        int u = queue[head++];
        order[pos++] = 'a' + u;
        for (int i = 0; i < 26; i++) {
            if (edges[u][i]) {
                indegrees[i]--;
                if (indegrees[i] == 0) {
                    queue[tail++] = i;
                }
            }
        }
    }
    for (int i = 0; i < 26; i++) {
        if (edges[i]) {
            free(edges[i]);
        }
    }
    free(queue);
    if (!valid || pos != edgesSize) {
        order[0] = '\0';
    }
    return order;
}
```

```JavaScript [sol2-JavaScript]
var alienOrder = function(words) {
    let valid = true;
    const edges = new Map();
    const indegrees = new Map();
    const length = words.length;
    for (const word of words) {
        const wordLength = word.length;
        for (let j = 0; j < wordLength; j++) {
            const c = word[j];
            if (!edges.has(c)) {
                edges.set(c, []);
            }
        }
    }

    const addEdge = (before, after) => {
        const length1 = before.length, length2 = after.length;
        const length = Math.min(length1, length2);
        let index = 0;
        while (index < length) {
            const c1 = before[index], c2 = after[index];
            if (c1 !== c2) {
                edges.get(c1).push(c2);
                indegrees.set(c2, (indegrees.get(c2) || 0) + 1);
                break;
            }
            index++;
        }
        if (index === length && length1 > length2) {
            valid = false;
        }
    }

    for (let i = 1; i < length && valid; i++) {
        addEdge(words[i - 1], words[i]);
    }
    if (!valid) {
        return "";
    }
    const queue = [];
    const letterSet = edges.keys();
    for (const u of letterSet) {
        if (!indegrees.has(u)) {
            queue.push(u);
        }
    }
    const order = [];
    while (queue.length) {
        const u = queue.shift();
        order.push(u);
        const adjacent = edges.get(u);
        for (const v of adjacent) {
            indegrees.set(v, indegrees.get(v) - 1);
            if (indegrees.get(v) === 0) {
                queue.push(v);
            }
        }
    }
    return order.length === edges.size ? order.join('') : "";
};
```

```go [sol2-Golang]
func alienOrder(words []string) string {
    g := map[byte][]byte{}
    inDeg := map[byte]int{}
    for _, c := range words[0] {
        inDeg[byte(c)] = 0
    }
next:
    for i := 1; i < len(words); i++ {
        s, t := words[i-1], words[i]
        for _, c := range t {
            inDeg[byte(c)] += 0
        }
        for j := 0; j < len(s) && j < len(t); j++ {
            if s[j] != t[j] {
                g[s[j]] = append(g[s[j]], t[j])
                inDeg[t[j]]++
                continue next
            }
        }
        if len(s) > len(t) {
            return ""
        }
    }

    order := make([]byte, len(inDeg))
    q := order[:0]
    for u, d := range inDeg {
        if d == 0 {
            q = append(q, u)
        }
    }
    for len(q) > 0 {
        u := q[0]
        q = q[1:]
        for _, v := range g[u] {
            if inDeg[v]--; inDeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    if cap(q) == 0 {
        return string(order)
    }
    return ""
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \times L + |\Sigma|)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{words}$ çš„é•¿åº¦ï¼Œå³å­—å…¸ä¸­çš„å•è¯æ•°ï¼Œ$L$ æ˜¯å­—å…¸ä¸­çš„å¹³å‡å•è¯é•¿åº¦ï¼Œ$\Sigma$ æ˜¯å­—å…¸ä¸­çš„å­—æ¯é›†åˆã€‚éå†å­—å…¸æ„é€ æœ‰å‘å›¾éœ€è¦ $O(n \times L)$ çš„æ—¶é—´ï¼Œç”±äºæœ‰å‘å›¾åŒ…å«æœ€å¤š $n - 1$ æ¡è¾¹å’Œ $|\Sigma|$ ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤å¹¿åº¦ä¼˜å…ˆæœç´¢éœ€è¦ $O(n + |\Sigma|)$ çš„æ—¶é—´ï¼Œæ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \times L + n + |\Sigma|) = O(n \times L + |\Sigma|)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n + |\Sigma|)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{words}$ çš„é•¿åº¦ï¼Œå³å­—å…¸ä¸­çš„å•è¯æ•°ï¼Œ$\Sigma$ æ˜¯å­—å…¸ä¸­çš„å­—æ¯é›†åˆã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºå­˜å‚¨æœ‰å‘å›¾éœ€è¦çš„ç©ºé—´ï¼Œæœ‰å‘å›¾åŒ…å«æœ€å¤š $n - 1$ æ¡è¾¹å’Œ $|\Sigma|$ ä¸ªèŠ‚ç‚¹ã€‚
# 2.ã€è¶…å¥½ç†è§£ã®é¢˜ç›®è§£æã€‘éš¾çš„ä¸æ˜¯æ‹“æ‰‘æ’åºï¼Œè€Œæ˜¯ç†è§£é¢˜æ„
# æäº¤è¡€æ³ªå²
åœ¨3æ¬¡æäº¤å¤±è´¥åï¼Œæˆ‘ç»ˆäºçœŸæ­£åœ°ç†è§£äº†é¢˜æ„ğŸ˜¶
![image.png](https://pic.leetcode-cn.com/1648952787-cXHMNK-image.png)

# é¢˜æ„è§£æ

è¿™é‡Œæˆ‘ä¸»è¦å¯¹é¢˜ç›®æœ€ååˆ—å‡ºçš„å­—å…¸åºè¯´æ˜è¿›è¡Œè§£é‡Šã€‚

> å­—ç¬¦ä¸²`s`å­—å…¸é¡ºåºå°äºå­—ç¬¦ä¸²`t`æœ‰ä¸¤ç§æƒ…å†µï¼š
> - åœ¨ç¬¬ä¸€ä¸ªä¸åŒå­—æ¯å¤„ï¼Œå¦‚æœ `s` ä¸­çš„å­—æ¯åœ¨è¿™é—¨å¤–æ˜Ÿè¯­è¨€çš„å­—æ¯é¡ºåºä¸­ä½äº `t` ä¸­å­—æ¯ä¹‹å‰ï¼Œé‚£ä¹ˆÂ `s` çš„å­—å…¸é¡ºåºå°äº `t` ã€‚
> - å¦‚æœå‰é¢ `min(s.length, t.length)` å­—æ¯éƒ½ç›¸åŒï¼Œé‚£ä¹ˆ `s.length < t.length` æ—¶ï¼Œ`s` çš„å­—å…¸é¡ºåºä¹Ÿå°äº `t` ã€‚

é¦–å…ˆï¼Œ**ç¬¬ä¸€ç§æƒ…å†µ**çš„æ„æ€æ˜¯ï¼š
- æˆ‘ä»¬èƒ½åšçš„äº‹åªæœ‰**æ’å‡ºå·²çŸ¥çš„é¡ºåº**ã€‚
> å‡è®¾ï¼š `words = ["wrt","wrf","er","ett","rftt"] `
> - å¯¹äº`wrt`å’Œ`wrf`ï¼Œæˆ‘ä»¬åªçŸ¥é“ç¬¬ä¸€ç»„ä¸åŒçš„å­—ç¬¦æ˜¯`t`å’Œ`f`ï¼Œæ ¹æ®å•è¯çš„é¡ºåºï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°`t`åº”å½“æ’åœ¨`f`å‰é¢ï¼Œå³`t -> f`. **æ³¨æ„ï¼Œè¿™é‡Œçš„ w å’Œ r å¹¶ä¸å­˜åœ¨å…ˆåå…³ç³»ã€‚**
> - åŒç†ï¼Œå¯¹äº`wrf`å’Œ`er`ï¼Œæˆ‘ä»¬åªèƒ½çŸ¥é“ç¬¬ä¸€ç»„ä¸åŒçš„å­—ç¬¦æ˜¯`w`å’Œ`e`ï¼Œé‚£ä¹ˆåªèƒ½å¾—åˆ°`w -> e`.

**ç¬¬äºŒç§æƒ…å†µ**ï¼Œä¸¾ä¸ªç®€å•ä¾‹å­å°±èƒ½æ˜ç™½ï¼š
> å‡è®¾ï¼š`words = ["wrt","wrtkj"] `, `s = "wrt", t = "wrtkj"`
> - `min(s.length, t.length) = s.length = 3`,ä¹Ÿå°±æ˜¯å‰3ä¸ªå­—ç¬¦éƒ½ç›¸åŒï¼Œé‚£ä¹ˆå½“`s.length < t.length`çš„æ—¶å€™ï¼Œå•è¯`s`åº”å½“æ’åœ¨å•è¯`t`å‰ã€‚

**ä»€ä¹ˆæƒ…å†µä¸‹ä¸åˆæ³•å‘¢ï¼Ÿ**
> å‡è®¾: `words = ["abc", "ab"]`ï¼Œé‚£ä¹ˆæ˜¾ç„¶è¿™ä¸¤ä¸ªå•è¯çš„å‰ä¸¤ä¸ªå­—ç¬¦éƒ½ç›¸åŒï¼Œ`abc`æ¯”`ab`å¤šäº†ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µä¸‹ï¼Œè¿˜æ’åœ¨äº†å‰é¢ï¼Œé‚£è¿™å°±è¿åäº†ä¸Šé¢çš„ç¬¬äºŒç§æƒ…å†µï¼Œæ‰€ä»¥æ˜¯ä¸åˆæ³•çš„ã€‚

**å¯¹äºæœªçŸ¥çš„å•è¯æˆ‘ä»¬åº”è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ**

è¿™ä¸ªä¾‹å­å¾ˆç¥å¥‡ï¼Œæˆ‘çœ‹è®¨è®ºåŒºå¾ˆå¤šå°ä¼™ä¼´éƒ½çº ç»“åœ¨è¿™é‡Œï¼Œæˆ‘ä¹Ÿè¯•å›¾ç”¨ç®€å•çš„è¯­è¨€å»è§£é‡Šä¸€ä¸‹ï¼š
> å‡è®¾ï¼š`words = ["z", "z"]`ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ— æ³•å¾—çŸ¥`z`ç©¶ç«Ÿæ˜¯ä»€ä¹ˆé¡ºåºï¼Œç´¢æ€§å°±ä¸ç”¨ç®¡å®ƒäº†ï¼Œå®ƒçš„é¡ºåºæ—¢ç„¶æ— ä»å¾—çŸ¥ï¼Œé‚£å°±éšä¾¿æ”¾åœ¨å­—å…¸çš„ä»»ä½•ä¸€ä¸ªä½ç½®éƒ½å¯ä»¥ï¼Œ**åªè¦æˆ‘ä»¬æ’åºå‡ºæ¥çš„å­—å…¸ä¸­ï¼Œé‚£éƒ¨åˆ†èƒ½å¤Ÿä»`words`ä¸­å¾—åˆ°çš„é‚£éƒ¨åˆ†å·²çŸ¥ä¿¡æ¯æ˜¯æ­£ç¡®é¡ºåºå°±å¯ä»¥ã€‚**
# ä»£ç å¦‚ä½•è®¾è®¡
æŒ‰ç…§ä¸Šé¢çš„åˆ†æï¼Œè§£é¢˜æ€è·¯ç®€å•æ¥è¯´å¦‚ä¸‹ï¼š
- æ ¹æ®å•è¯è¡¨ï¼ŒæŠŠå·²çŸ¥çš„å­—ç¬¦é¡ºåºç¡®å®šä¸‹æ¥ï¼Œå»ºç«‹ä¸€ä¸ªæœ‰å‘å›¾ï¼ŒæŒ‰ç…§å­—å…¸åºå°çš„æŒ‡å‘å­—å…¸åºå¤§çš„ä¸ºæ–¹å‘ã€‚
- æ ¹æ®å»ºç«‹å¥½çš„å›¾ï¼ŒDFS æˆ– BFS è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯å·²çŸ¥çš„é‚£éƒ¨åˆ†å­—ç¬¦çš„å­—å…¸åºã€‚
- **å¾—åˆ°äº†æ‹“æ‰‘æ’åºç»“æœä¹‹åï¼ŒæŠŠæœªçŸ¥é¡ºåºçš„å­—ç¬¦éšæ„æ”¾ç½®åœ¨æ’åºç»“æœä¸­ï¼Œè¿™ä¸€æ­¥åªè¦ä¿è¯ä¸å­˜åœ¨é‡å¤å­—ç¬¦å³å¯ã€‚**   æ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦ç»Ÿè®¡ä¸€ä¸‹å•è¯è¡¨ä¸­æ‰€æœ‰å‡ºç°è¿‡çš„å­—ç¬¦ã€‚

# æœ¬é¢˜é¢˜è§£
æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œåˆ†å—ç»„ç»‡ä»£ç ï¼Œå®Œæ•´ä»£ç åœ¨æœ€åã€‚

1.æ„å»ºå­—ç¬¦é›†
```Java []
public String alienOrder(String[] words) {
    // 1.æ„å»ºå­—ç¬¦é›†
    Set<Character> unknown = new HashSet<>();
    for(String word : words){
        for(int i = 0; i < word.length(); i++){
            unknown.add(word.charAt(i));
        }
    }
    // ...
}
```
2.å»ºç«‹æœ‰å‘å›¾ï¼Œä½¿ç”¨Mapç»“æ„
```Java []
public String alienOrder(String[] words) {
    // 1.æ„å»ºå­—ç¬¦é›†
    // ...
    
    // 2.å»ºç«‹æœ‰å‘å›¾
    Map<Character, List<Character>> graph = new HashMap<>();
    int n = words.length;
    for(int i = 0; i < n - 1; i++){
        String w1 = words[i], w2 = words[i + 1];
        int maxLen = Math.max(w1.length(), w2.length());
        for(int j = 0; j < maxLen; j++){
            if(j == w2.length()) return "";//ä¸åˆæ³•
            if(j == w1.length()) break;

            if(w1.charAt(j) != w2.charAt(j)){
                char from = w1.charAt(j), to = w2.charAt(j);
                if(graph.get(from) == null){
                    graph.put(from, new LinkedList<>());
                }
                graph.get(from).add(to);
                break; // åªæœ‰ç¬¬ä¸€ä¸ªä¸åŒçš„å­—æ¯å¯ä»¥ç¡®å®šé¡ºåº
            }
        }
    }
}
```
3.æ‹“æ‰‘æ’åº
```Java []
public String alienOrder(String[] words) {
    // 1.æ„å»ºå­—ç¬¦é›†
    // 2.å»ºç«‹æœ‰å‘å›¾
    // 3.æ‹“æ‰‘æ’åº
    visited = new boolean[26];
    onPath = new boolean[26];
    path = new StringBuilder();
    for(char ch : graph.keySet()){
        traverse(graph, ch);
    }
}
boolean[] visited; // è®°å½•ç»“ç‚¹è®¿é—®æƒ…å†µ
boolean[] onPath; // è®°å½•è·¯å¾„è®¿é—®æƒ…å†µ
boolean hasCycle; // å­˜åœ¨ç¯æ ‡å¿—
StringBuilder path;// è®°å½•æ’åºç»“æœ

// æ‹“æ‰‘æ’åºå‡½æ•°
void traverse(Map<Character, List<Character>> graph, char ch){
    if(onPath[ch - 'a']) hasCycle = true;//è¯¥è·¯å¾„æ›¾ç»è®¿é—®è¿‡ï¼Œå­˜åœ¨ç¯
    if(hasCycle || visited[ch - 'a']) return; // å­˜åœ¨ç¯æˆ–è€…å·²è®¿é—®è¿‡è¯¥èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›

    visited[ch - 'a'] = true;
    onPath[ch - 'a'] = true;
    if(graph.get(ch) != null){
        for(char next : graph.get(ch)){
            traverse(graph, next);
        }
    }
    path.append(ch);
    onPath[ch - 'a'] = false;
}
```

4.ç»„ç»‡æœ€ç»ˆå­—å…¸åºç»“æœï¼ŒæŠŠæ— æ³•ç¡®å®šé¡ºåºçš„å•è¯åŠ å…¥å·²æ’åºçš„å­—å…¸åºåˆ—ä¸­ã€‚
```Java []
public String alienOrder(String[] words) {
    // 1.æ„å»ºå­—ç¬¦é›†...
    // 2.æ„å»ºæœ‰å‘å›¾...
    // 3.æ‹“æ‰‘æ’åº...

    // 4.ç»„ç»‡æœ€ç»ˆç­”æ¡ˆ
    if(hasCycle) return "";//å­˜åœ¨ç¯åˆ™æ— æ³•æ’åºå‡ºåˆæ³•çš„å­—æ¯é¡ºåº
    for(char unk : unknown){
        if(path.indexOf(String.valueOf(unk)) == -1){
            path.append(unk);
        }
    }
    return path.reverse().toString();
}
```

**å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š**
```Java []
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, List<Character>> graph = new HashMap<>();
        int n = words.length;
        Set<Character> unknown = new HashSet<>();
        for(String word : words){
            for(int i = 0; i < word.length(); i++){
                unknown.add(word.charAt(i));
            }
        }
        // 1. build graph
        for(int i = 0; i < n - 1; i++){
            String w1 = words[i], w2 = words[i + 1];
            int maxLen = Math.max(w1.length(), w2.length());
            for(int j = 0; j < maxLen; j++){
                if(j == w2.length()) return "";//ä¸åˆæ³•
                if(j == w1.length()) break;
                if(w1.charAt(j) != w2.charAt(j)){
                    char from = w1.charAt(j), to = w2.charAt(j);
                    if(graph.get(from) == null){
                        graph.put(from, new LinkedList<>());
                    }
                    graph.get(from).add(to);
                    break;//æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒå­—æ¯ï¼Œå¯ä»¥åˆ¤æ–­é¡ºåº
                }
            }

        }
        // 2.topological sort
        visited = new boolean[26];
        onPath = new boolean[26];
        path = new StringBuilder();
        for(char ch : graph.keySet()){
            traverse(graph, ch);
        }
        // 3. get final result
        if(hasCycle) return "";//å­˜åœ¨ç¯åˆ™æ— æ³•æ’åºå‡ºåˆæ³•çš„å­—æ¯é¡ºåº
        for(char unk : unknown){
            if(path.indexOf(String.valueOf(unk)) == -1){
                path.append(unk);
            }
        }
        return path.reverse().toString();

    }

    boolean[] visited;//è®°å½•ç»“ç‚¹è®¿é—®
    boolean[] onPath;//è®°å½•è·¯çº¿è®¿é—®
    boolean hasCycle;//å­˜åœ¨ç¯æ ‡å¿—
    StringBuilder path;

    void traverse(Map<Character, List<Character>> graph, char ch){
        if(onPath[ch - 'a']) hasCycle = true;//è¯¥è·¯å¾„æ›¾ç»è®¿é—®è¿‡ï¼Œå­˜åœ¨ç¯
        if(hasCycle || visited[ch - 'a']) return; // å­˜åœ¨ç¯æˆ–è€…å·²è®¿é—®è¿‡è¯¥èŠ‚ç‚¹ è¿”å›
        visited[ch - 'a'] = true;
        onPath[ch - 'a'] = true;
        if(graph.get(ch) != null){
            for(char next : graph.get(ch)){
                traverse(graph, next);
            }
        }
        path.append(ch);
        onPath[ch - 'a'] = false;
    }

}
```

æ¬¢è¿åœ¨è¯„è®ºåŒºè®¨è®ºï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹æ¬¢è¿å¤§å®¶æŒ‡æ­£ã€‚
# 3.ã€yukiyamaã€‘269 æ‹“æ‰‘æ’åº
# 269-ç«æ˜Ÿè¯å…¸

[269. ç«æ˜Ÿè¯å…¸](https://leetcode.cn/problems/alien-dictionary/) (å›°éš¾)

<br />

## è§£æ³•ä¸€ï¼šæ‹“æ‰‘æ’åº

### ç®—æ³•æè¿°

è¯»é¢˜åä¸éš¾æ„Ÿè§‰åˆ°æ˜¯ä¸ªæ‹“æ‰‘æ’åºé¢˜ï¼Œäºæ˜¯å¼€å§‹æ„æ€å¦‚ä½•å»ºå›¾ã€‚æ˜¾ç„¶å•ä¸ªå­—ç¬¦æ˜¯é¡¶ç‚¹ï¼Œè€Œè¾¹çš„å…³ç³»è•´å«åœ¨å•è¯é¡ºåºä¸­ã€‚å…ˆç»™å‡ºå…³äºè¾¹çš„ç»“è®ºï¼Œè¾¹ä»…ç”±ç›¸é‚»å•è¯ $w1$ å’Œ $w2$ çš„ **ã€Œç¬¬ä¸€å¯¹åŒä¸‹æ ‡ç›¸å¼‚å­—ç¬¦ã€** ç»™å‡ºã€‚ä¾‹å¦‚æ ¹æ®æŒ‰ç…§è¯å…¸åºæ’æ”¾çš„ç›¸é‚»å•è¯ $word$ å’Œ $world$ ï¼Œå¯ä»¥æ‰¾åˆ°ä¸€æ¡è¾¹ï¼Œå³ã€Œç¬¬ä¸€å¯¹åŒä¸‹æ ‡ç›¸å¼‚å­—ç¬¦ã€ $d$ å’Œ $l$ ï¼Œ $d$ æŒ‡å‘ $l$ ï¼ˆ $d$ çš„å­—å…¸åºå…ˆäº $l$ ï¼‰ã€‚é‚£ä¹ˆå¯¹äºæœ‰ $n$ ä¸ªå•è¯çš„ $words$ å­—ç¬¦ä¸²æ•°ç»„ï¼Œå› ä¸ºæœ‰ $n-1$ å¯¹ç›¸é‚»å•è¯ï¼Œæ‰€ä»¥æœ€å¤šèƒ½å¤Ÿæ„æˆä¸€å¼ å…·æœ‰ $n-1$ æ¡è¾¹çš„å›¾ã€‚

**æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ ¹æ®ä¸Šè¿°ç†è§£æ„å»ºä»¥å­—ç¬¦ä¸ºé¡¶ç‚¹ï¼Œä»¥å­—ç¬¦å­—å…¸åºä¸ºè¾¹çš„å›¾ï¼Œç„¶åè¾“å‡ºè¿™å¼ å›¾çš„æ‹“æ‰‘æ’åºç»“æœã€‚**  å®é™…ä¸Šæˆ‘ä»¬ç°åœ¨è¿˜ä¸çŸ¥é“å“ªäº›å­—ç¬¦åº”è¯¥ä½œä¸ºå›¾ä¸Šçš„é¡¶ç‚¹ï¼Œæ¯”å¦‚æ˜¯å¦è¦å°†æ‰€æœ‰å‡ºç°çš„å­—ç¬¦éƒ½ä½œä¸ºé¡¶ç‚¹ï¼Œè¿˜æ˜¯åªå°†å†³å®šäº†è¾¹çš„å­—ç¬¦ä½œä¸ºé¡¶ç‚¹ã€‚è¿™æ˜¯éœ€è¦æ ¹æ®é¢˜æ„ï¼Œç”šè‡³æ˜¯ä¸€äº›æµ‹è¯•ä¾‹å­æ¥åˆ†æå¾—åˆ°çš„ã€‚

<br />

#### æƒ…å½¢åˆ†æ

ç°åœ¨åˆ†æä¸€äº›ç‰¹æ®Šæƒ…å½¢ã€‚

**æƒ…å½¢ä¸€ï¼š $w1$ æ˜¯ $w2$ çš„å‰ç¼€ã€‚**

ä¹Ÿå°±æ˜¯é¢˜ç›®æè¿°ä¸­æåˆ°çš„å¦‚ä¸‹:

> å¦‚æœå‰é¢ $min(s.length, t.length)$ å­—æ¯éƒ½ç›¸åŒï¼Œé‚£ä¹ˆ $s.length < t.length$ æ—¶ï¼Œ$s$ çš„å­—å…¸é¡ºåºä¹Ÿå°äº $t$ ã€‚

è¿™ç§æƒ…å†µä¸‹ $s$ å’Œ $t$ è¿™ä¸¤ä¸ªå•è¯æ— æ³•ç¡®å®šä»»ä½•ä¸€æ¡è¾¹ï¼Œä½†å´æ˜¯åˆæ³•çš„ï¼Œå¹¶ä¸” $s$ çš„å­—å…¸é¡ºåºå°äº $t$ ã€‚å®é™…ä¾‹å­æ˜¯ `["ab","abc"]` ï¼Œå°†ä¼šè¾“å‡º `"abc"` ã€‚å°½ç®¡æ²¡æœ‰è¾¹å­˜åœ¨ï¼Œä½†æ‹“æ‰‘æ’åºåä»ä¼šè¾“å‡ºæ‰€æœ‰å‡ºç°è¿‡çš„å­—ç¬¦ï¼Œè¿™è¡¨ç¤ºæˆ‘ä»¬åº”è¯¥å°† **æ‰€æœ‰å­—ç¬¦** éƒ½ä½œä¸ºå›¾çš„é¡¶ç‚¹ã€‚é‚£ä¹ˆæœ€ç»ˆçš„å›¾å¯èƒ½æ˜¯ **ä¸è¿é€š**  çš„ï¼Œæ¯”å¦‚å‰é¢çš„ä¾‹å­ï¼Œå›¾ç”±ä¸‰ä¸ªç‹¬ç«‹çš„é¡¶ç‚¹ $a,b,c$ æ„æˆã€‚ç”±äºå…¥åº¦éƒ½æ˜¯ 0ï¼Œç»è¿‡æ‹“æ‰‘æ’åºåä¼šè¾“å‡º `"abc"` ã€‚è¿™æ˜¯æŒ‰ **å­—ç¬¦å‡ºç°é¡ºåº** è¾“å‡ºçš„ç»“æœï¼Œå› ä¸ºæ— æ³•ç¡®å®šä»–ä»¬ä¹‹é—´çš„å­—å…¸åºï¼Œæ‰€ä»¥ **ä»»æ„æ’åˆ—éƒ½æ˜¯åˆæ³•çš„è¾“å‡º** ã€‚

**æƒ…å½¢äºŒï¼š $w2$ æ˜¯ $w1$ çš„å‰ç¼€**

ä¾‹å¦‚ `["abc","ab"]` ï¼ŒåŒæ ·æ— è¾¹çš„å…³ç³»ï¼Œè™½ç„¶é¢˜ç›®ä¸­æ²¡æœ‰ç‰¹åˆ«å¼ºè°ƒï¼Œä½†æŒ‰ç…§æ­£å¸¸çš„è¯å…¸é€»è¾‘ï¼Œ **è¿™ç§é¡ºåºæ˜¾ç„¶æ˜¯éæ³•çš„** ã€‚å› æ­¤åœ¨æ‰¾è¾¹å»ºå›¾è¿‡ç¨‹ä¸­æ£€æµ‹åˆ°è¿™ç§æƒ…å½¢ï¼Œå¯ç›´æ¥è¿”å›ç©ºä¸²ã€‚

**æƒ…å½¢ä¸‰ï¼šä¸å±äºä»»ä½•è¾¹çš„å­¤ç«‹é¡¶ç‚¹**

ä¾‹å¦‚ `["zx","zy"]` ï¼Œç¡®å®šäº†ä¸€æ¡ä» $x$ åˆ° $y$ çš„è¾¹ï¼Œä¸”å›¾åªæœ‰ä¸€æ¡è¾¹ï¼Œ $z$ æ˜¯ä¸€ä¸ªå­¤ç«‹é¡¶ç‚¹ã€‚å› ä¸ºè¯¥è¾“å…¥åˆæ³•ï¼Œæ‰€ä»¥è¾“å‡ºç»“æœè¦åŒ…å«æ‰€æœ‰å­—ç¬¦ã€‚å®é™…ä¸Šåœ¨æƒ…å½¢ä¸€ä¸­ä¹Ÿæåˆ°äº†ï¼Œåªéœ€è¦å°† $z$ ä¹Ÿä½œä¸ºå›¾çš„é¡¶ç‚¹å³å¯ã€‚åœ¨æ‹“æ‰‘æ’åºæ—¶ï¼Œå› ä¸º $z$ çš„å…¥åº¦ä¸º0ï¼Œä¼šè¢«æå‰è¾“å‡ºåˆ°ç»“æœä¸­ã€‚æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œè¾“å‡ºç»“æœåªéœ€è¦ä¿è¯ $x$ åœ¨ $y$ ä¹‹å‰å³å¯ï¼Œ$z$ çš„ä½ç½®æ˜¯ä»»æ„çš„ã€‚

**æƒ…å½¢å››ï¼šæœ‰åœˆå›¾**

é¢˜ç›®çš„ç¤ºä¾‹ä¸‰ `["z","x","z"]` è¡¨æ˜ï¼Œå½“å›¾æ˜¯ä¸€ä¸ªåœˆæ—¶ï¼Œè¿”å› **ç©ºä¸²** ã€‚è¿™é‡Œæƒ³å¼ºè°ƒçš„æ˜¯ï¼Œä¸å…‰æ˜¯åœˆå›¾éæ³•ï¼Œåªè¦æœ‰åœˆå°±è§†ä½œéæ³•è¾“å…¥ï¼Œéœ€è¦è¿”å›ç©ºä¸²ã€‚ä¾‹å¦‚`["w","z","x","z"]` ï¼ŒæŒ‰ç…§æ‹“æ‰‘æ’åºï¼Œç»“æœæ˜¯ `"z"` ï¼Œä½†å› ä¸ºå­˜åœ¨åœˆï¼Œè¿™ä¸ªè¾“å…¥è§†ä½œéæ³•ï¼Œ**æ­£ç¡®çš„ç»“æœæ˜¯è¿”å›ç©ºä¸²** ã€‚

<br />

#### è§£æ³•æ€»ç»“

æœ‰äº†ä¸Šè¿°åˆ†æï¼Œå®é™…ä¸Šè¿™é¢˜å°±æ˜¯ä¸ªç®€å•é¢˜äº†ï¼Œåœ¨æ‰¾è¾¹æ—¶åˆ¤æ–­æ˜¯å¦ä¸ºæƒ…å½¢äºŒçš„éæ³•è¾“å…¥ï¼Œéæ³•åˆ™ç›´æ¥è¿”å›ç©ºä¸²ï¼Œåˆæ³•åˆ™å°†æ‰€æœ‰å­—ç¬¦è§†ä½œæœ‰æ•ˆé¡¶ç‚¹ï¼Œä¸”åˆå§‹å…¥åº¦ä¸º 0 ã€‚å¸¸è§„å»ºå›¾ï¼Œå¸¸è§„æ‹“æ‰‘æ’åºï¼Œåªæ˜¯éœ€è¦å†åšä¸€ä¸‹åœˆæ£€æµ‹ï¼Œå›¾æœ‰åœˆåˆ™è¾“å…¥éæ³•ï¼Œè¿”å›ç©ºä¸²ã€‚

è™½ç„¶å»ºå›¾å’Œåˆå§‹åŒ–å…¥åº¦å¯ä»¥åœ¨ä¸€ä¸ªæ–¹æ³•å†…å®Œæˆã€‚ä½†è€ƒè™‘ç¡®å®šè¾¹çš„åŒæ—¶ï¼Œå¯¹è¾“å…¥è¿›è¡Œéæ³•æ£€æµ‹ï¼Œè‹¥éæ³•ï¼Œåˆ™æ— éœ€å†ç¡®å®šå…¥åº¦å’Œå»ºå›¾äº†ã€‚å¹¶ä¸”ä»å¯è¯»æ€§ä¸Šæ¥è¯´ï¼ŒæŠŠç¡®å®šè¾¹å’Œåˆå§‹åŒ–å…¥åº¦åˆ†å¼€å†™æ›´å¥½ã€‚

```markdown
1. å»ºå›¾ & åˆå§‹åŒ–å…¥åº¦ã€‚
1.1 ç¡®å®šè¾¹ã€‚éå†wordsï¼Œæ ¹æ®æ¯ä¸€å¯¹ç›¸é‚»å•è¯çš„ã€Œç¬¬ä¸€å¯¹åŒä¸‹æ ‡ç›¸å¼‚å­—ç¬¦ã€ç¡®å®šè¾¹ã€‚
1.2 ä¸Šè¿°è¿‡ç¨‹ä¼šå¯¹wordsè¿›è¡Œéæ³•æ£€æµ‹ï¼Œè‹¥å‡ºç°æƒ…å½¢äºŒçš„éæ³•ç›¸é‚»å•è¯ï¼Œ
    ä¸Šè¿°æ–¹æ³•ä¸­ä¼šä»¤ç±»å­—æ®µinvalidInputä¸ºtrueã€‚æ­¤å¤„åˆ¤æ–­ä¸€ä¸‹è¯¥å­—æ®µï¼Œéæ³•åˆ™ç›´æ¥è¿”å›ç©ºä¸²ã€‚
1.3 åˆå§‹åŒ–å…¥åº¦ï¼ˆä¹Ÿå³ç¡®å®šé¡¶ç‚¹ï¼‰ã€‚éå†wordsï¼Œå°†æ¯ä¸€ä¸ªä¸é‡å¤å­—ç¬¦çš„å…¥åº¦ç½®ä¸º0ï¼Œ
    å…¶ä»–ä¸º-1.ï¼ˆå› æ­¤å…¥åº¦ä¸º0çš„å­—ç¬¦å³å›¾çš„é¡¶ç‚¹ï¼‰æ ¹æ®è¾¹å»ºå›¾ã€‚
2. æ‹“æ‰‘æ’åºã€‚æ’åºè¿‡ç¨‹ä¸­åˆ©ç”¨æ’åºé¡¶ç‚¹æ•°å’Œæ€»é¡¶ç‚¹æ•°å…³ç³»ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ç¯ã€‚
    æ— ç¯å›¾æ‰€æœ‰é¡¶ç‚¹éƒ½å°†æ’åºï¼Œæ•…è‹¥æ’åºæ•°ä¸ç­‰äºé¡¶ç‚¹æ€»æ•°ï¼Œåˆ™æœ‰ç¯ã€‚
```

<br />

### æ—¶ç©ºå¤æ‚åº¦

æ—¶é—´å¤æ‚åº¦ï¼š$O(n*L+âˆ£Î£âˆ£)$  n æ˜¯å•è¯ä¸ªæ•°ï¼ŒL æ˜¯å•è¯å¹³å‡é•¿åº¦ã€‚æ„å»ºå›¾æœ€å¤šéœ€è¦éå†æ¯ä¸€ä¸ªå•è¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n*L)$ ã€‚ $|Î£|$ æ˜¯å­—å…¸ä¸­å­—æ¯æ•°ï¼Œå¯¹åº”å›¾ä¸­é¡¶ç‚¹æ•°ã€‚æ‹“æ‰‘æ’åºæ—¶é—´å¤æ‚åº¦ä¸º $O(n + |Î£|)$ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(n+âˆ£Î£âˆ£)$ ï¼Œå–å†³äºå›¾æ‰€éœ€çš„å­˜å‚¨ç©ºé—´ï¼Œå³é¡¶ç‚¹æ•°å’Œè¾¹æ•°ã€‚

<br />

### ä»£ç 

```java
class Solution {
    public String alienOrder(String[] words) {
        int n = words.length, V_NUM = 26;
        int[] indegree = new int[V_NUM]; // å…¥åº¦
        Arrays.fill(indegree, -1);
        for(String word : words) { // åˆå§‹åŒ–å…¥åº¦ï¼Œå€¼ä¸º0è¡¨ç¤ºé¡¶ç‚¹ï¼Œ-1è¡¨ç¤ºéé¡¶ç‚¹
            char[] chs = word.toCharArray();
            for(char ch : chs) indegree[ch - 'a'] = 0;
        }
        List<List<Integer>> graph = new ArrayList<>(); // é‚»æ¥è¡¨
        for(int i = 0; i < V_NUM; i++) graph.add(new ArrayList<>());
        for(int i = 0; i < n - 1; i++){ // æ„å»ºindgreeå’Œgraph
            String w1 = words[i], w2 = words[i + 1];
            char[] chs1 = w1.toCharArray(), chs2 = w2.toCharArray();
            int w1n = w1.length(), w2n = w2.length();
            int wn = w1n < w2n ? w1n : w2n, j = 0;            
            for(; j < wn; j++){
                int u = chs1[j] - 'a', v = chs2[j] - 'a'; // u > v
                if(u != v) {
                    graph.get(u).add(v);
                    indegree[v]++; 
                    break; // ä¸€å¯¹ç›¸é‚»å•è¯æœ€å¤šå†³å®šä¸€æ¡è¾¹ï¼Œå¤„ç†è¿™æ¡è¾¹åç›´æ¥break
                }
            }
            if(j == wn && w1n > w2n) return ""; // word2ä¸ºword1çš„çœŸå‰ç¼€ï¼Œéæ³•è¾“å…¥
        }
        return topoSort(graph, indegree);
    }
    // æ‹“æ‰‘æ’åºï¼Œæ’åºè¿‡ç¨‹ä¸­åˆ¤æ–­å›¾æ˜¯å¦æœ‰åœˆ
    private String topoSort(List<List<Integer>> graph, int[] indegree){
        StringBuilder sb = new StringBuilder();
        Queue<Integer> q = new ArrayDeque<>();
        int count = 0, vNum = 0; // æ‹“æ‰‘æ’åºè®¡æ•° & å›¾ä¸­æ€»èŠ‚ç‚¹æ•°
        for(int i = 0; i < indegree.length; i++){ // å°†å…¥åº¦ä¸º0çš„é¡¶ç‚¹åŠ å…¥qä¸­
            if(indegree[i] != -1) {
                vNum++; // å­˜åœ¨
                if(indegree[i] == 0){ // å­˜åœ¨ä¸”å…¥åº¦ä¸º0
                    q.add(i);
                    sb.append((char) (i + 'a')); // å…¥åº¦ä¸º0çš„é¡¶ç‚¹å…ˆè¾“å‡º
                    count++; // æ’åºä¸€ä¸ªè®¡æ•°ä¸€ä¸ª
                }
            }
        }
        while(!q.isEmpty()){ // æ‹“æ‰‘æ’åº
            int u = q.remove();
            for(int v : graph.get(u)){
                indegree[v]--;
                if(indegree[v] == 0){
                    q.add(v);
                    sb.append((char) (v + 'a'));
                    count++; // æ’åºä¸€ä¸ªè®¡æ•°ä¸€ä¸ª
                }
            }
        }
        return count != vNum ? "" : sb.toString(); // åˆ¤æ–­æ˜¯å¦æœ‰åœˆ
    }
}
```

<br />


# 4.Java æ‹“æ‰‘æ’åº
**æˆ‘çš„[leetcodeè§£é¢˜é›†](https://github.com/JuiceZhou/Leetcode)ï¼Œæ±‚å°æ˜Ÿæ˜Ÿå‘€(à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆâœ§**

æ€è·¯ï¼š

å°†è¯å…¸ä¸­å­—ç¬¦ä¸²çš„å­—ç¬¦ä¸¤ä¸¤å¯¹æ¯”ï¼Œåªæœ‰ç¬¬ä¸€ä¸ªä¸åŒçš„å­—ç¬¦æ‰æ˜¯æ­£ç¡®çš„æ’åºï¼Œå¦‚`ert`å’Œ`wrf`ï¼Œåªèƒ½æ¨æ–­å‡º`e`çš„ä¼˜å…ˆçº§é«˜äº`w`ï¼Œå‰©ä½™å­—ç¬¦çš„ä¼˜å…ˆçº§ä¸èƒ½æ¨æ–­ã€‚

å°†å­—ç¬¦ä¸²çš„ä¼˜å…ˆçº§æ„å»ºä¸ºå›¾ï¼Œç„¶åè¿›è¡Œæ‹“æ‰‘æ’åºã€‚å¦‚æœå›¾ä¸­æ— ç¯ï¼Œåˆ™å°†æ‹“æ‰‘æ’åºè¾“å‡ºï¼Œå¦åˆ™é¡ºåºæ˜¯éæ³•çš„ã€‚

æ³¨æ„å¯¹äºè¾“å…¥`"za"`,`"zb"`,`"ca"`,`"cb"`ï¼Œå­—ç¬¦å…³ç³»ä¸º`a->bã€z->c`ï¼Œè¾“å‡ºå¯ä»¥ä¸º`azbc`ã€`zacb`ï¼Œåªè¦è¾“å‡ºä¸€ç§å³å¯ã€‚


```
class Solution {
    public String alienOrder(String[] words) {
        //1.æ„å»ºå›¾
        Map<Character, Set<Character>> map = new HashMap<>();
        for (int i = 0; i < words.length - 1; i++) {
            for (int j = 0; j < words[i].length() && j < words[i + 1].length(); j++) {
                //å¦‚æœå­—ç¬¦ç›¸åŒï¼Œæ¯”è¾ƒä¸‹ä¸€ä¸ª
                if (words[i].charAt(j) == words[i + 1].charAt(j)) continue;
                //ä¿å­˜ç¬¬ä¸€ä¸ªä¸åŒçš„å­—ç¬¦é¡ºåº
                Set<Character> set = map.getOrDefault(words[i].charAt(j), new HashSet<>());
                set.add(words[i + 1].charAt(j));
                map.put(words[i].charAt(j), set);
                break;
            }
        }

        //2.æ‹“æ‰‘æ’åº
        //åˆ›å»ºä¿å­˜å…¥åº¦çš„æ•°ç»„
        int[] degrees = new int[26];
        Arrays.fill(degrees, -1);
        //æ³¨æ„ï¼Œä¸æ˜¯26å­—æ¯éƒ½åœ¨wordsä¸­å‡ºç°ï¼Œæ‰€ä»¥å‡ºåº¦åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼šæ²¡æœ‰å‡ºç°çš„å­—æ¯å‡ºåº¦ä¸º-1ï¼Œå‡ºç°äº†çš„å­—æ¯çš„å‡ºåº¦ä¸ºéè´Ÿæ•°
        for (String str : words) {
            //å°†å‡ºç°è¿‡çš„å­—ç¬¦çš„å‡ºåº¦è®¾å®šä¸º0
            for (char c : str.toCharArray())
                degrees[c - 'a'] = 0;
        }
        for (char key : map.keySet()) {
            for (char val : map.get(key)) {
                degrees[val - 'a']++;
            }
        }
        //åˆ›å»ºStringBuilderä¿å­˜æ‹“æ‰‘æ’åº
        StringBuilder sb = new StringBuilder();
        //åˆ›å»ºä¸€ä¸ªQueueä¿å­˜å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
        Queue<Character> list = new LinkedList<>();

        int count = 0;//è®¡ç®—å›¾ä¸­èŠ‚ç‚¹æ•°
        for (int i = 0; i < 26; i++) {
            if (degrees[i] != -1) count++;
            if (degrees[i] == 0) {
                list.add((char) ('a' + i));
            }
        }

        while (!list.isEmpty()) {
            Character cur = list.poll();
            sb.append(cur);
            //å°†é‚»æ¥ç‚¹å‡ºåº¦-1
            if (map.containsKey(cur)) {
                Set<Character> set = map.get(cur);
                for (Character c : set) {
                    degrees[c - 'a']--;
                    if (degrees[c - 'a'] == 0) list.add(c);
                }
            }
        }

        //åˆ¤æ–­æ˜¯å¦æœ‰ç¯
        if (sb.length() != count) return "";
        else return sb.toString();

    }
}
```

