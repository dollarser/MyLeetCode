# 269火星词典
<p>现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。</p>

<p>给你一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p>

<p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>""</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p>

<p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p>

<ul>
	<li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么 <code>s</code> 的字典顺序小于 <code>t</code> 。</li>
	<li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length < t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>words = ["wrt","wrf","er","ett","rftt"]
<strong>输出：</strong>"wertf"
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>words = ["z","x"]
<strong>输出：</strong>"zx"
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>words = ["z","x","z"]
<strong>输出：</strong>""
<strong>解释：</strong>不存在合法字母顺序，因此返回 <code>"" 。</code>
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= words.length <= 100</code></li>
	<li><code>1 <= words[i].length <= 100</code></li>
	<li><code>words[i]</code> 仅由小写英文字母组成</li>
</ul>
































# 解题:
# 1.火星词典
#### 前言

这道题是拓扑排序问题。火星词典中的字母和字母顺序可以看成有向图，字典顺序即为所有字母的一种排列，满足每一条有向边的起点字母和终点字母的顺序都和这两个字母在排列中的顺序相同，该排列即为有向图的拓扑排序。

只有当有向图中无环时，才有拓扑排序，且拓扑排序可能不止一种。如果有向图中有环，则环内的字母不存在符合要求的排列，因此没有拓扑排序。

使用拓扑排序求解时，将火星词典中的每个字母看成一个节点，将字母之间的顺序关系看成有向边。对于火星词典中的两个相邻单词，同时从左到右遍历，当遇到第一个不相同的字母时，该位置的两个字母之间即存在顺序关系。

以下两种情况不存在合法字母顺序：

- 字母之间的顺序关系存在由至少 $2$ 个字母组成的环，例如 $\textit{words} = [\text{``a"}, \text{``b"}, \text{``a"}]$；

- 相邻两个单词满足后面的单词是前面的单词的前缀，且后面的单词的长度小于前面的单词的长度，例如 $\textit{words} = [\text{``ab"}, \text{``a"}]$。

其余情况下都存在合法字母顺序，可以使用拓扑排序得到字典顺序。

拓扑排序可以使用深度优先搜索或广度优先搜索实现，以下分别介绍两种实现方法。

#### 方法一：拓扑排序 + 深度优先搜索

使用深度优先搜索实现拓扑排序的总体思想是：对于一个特定节点，如果该节点的所有相邻节点都已经搜索完成，则该节点也会变成已经搜索完成的节点，在拓扑排序中，该节点位于其所有相邻节点的前面。一个节点的相邻节点指的是从该节点出发通过一条有向边可以到达的节点。

由于拓扑排序的顺序和搜索完成的顺序相反，因此需要使用一个栈存储所有已经搜索完成的节点。深度优先搜索的过程中需要维护每个节点的状态，每个节点的状态可能有三种情况：「未访问」、「访问中」和「已访问」。初始时，所有节点的状态都是「未访问」。

每一轮搜索时，任意选取一个「未访问」的节点 $u$，从节点 $u$ 开始深度优先搜索。将节点 $u$ 的状态更新为「访问中」，对于每个与节点 $u$ 相邻的节点 $v$，判断节点 $v$ 的状态，执行如下操作：

- 如果节点 $v$ 的状态是「未访问」，则继续搜索节点 $v$；

- 如果节点 $v$ 的状态是「访问中」，则找到有向图中的环，因此不存在拓扑排序；

- 如果节点 $v$ 的状态是「已访问」，则节点 $v$ 已经搜索完成并入栈，节点 $u$ 尚未入栈，因此节点 $u$ 的拓扑顺序一定在节点 $v$ 的前面，不需要执行任何操作。

当节点 $u$ 的所有相邻节点的状态都是「已访问」时，将节点 $u$ 的状态更新为「已访问」，并将节点 $u$ 入栈。

当所有节点都访问结束之后，如果没有找到有向图中的环，则存在拓扑排序，所有节点从栈顶到栈底的顺序即为拓扑排序。

实现方面，由于每个节点是一个字母，因此可以使用字符数组代替栈，当节点入栈时，在字符数组中按照从后往前的顺序依次填入每个字母。当所有节点都访问结束之后，将字符数组转成字符串，即为字典顺序。

<![ppt0](https://assets.leetcode-cn.com/solution-static/269/0.PNG),![ppt1](https://assets.leetcode-cn.com/solution-static/269/1.PNG),![ppt2](https://assets.leetcode-cn.com/solution-static/269/2.PNG),![ppt3](https://assets.leetcode-cn.com/solution-static/269/3.PNG),![ppt4](https://assets.leetcode-cn.com/solution-static/269/4.PNG),![ppt5](https://assets.leetcode-cn.com/solution-static/269/5.PNG),![ppt6](https://assets.leetcode-cn.com/solution-static/269/6.PNG),![ppt7](https://assets.leetcode-cn.com/solution-static/269/7.PNG),![ppt8](https://assets.leetcode-cn.com/solution-static/269/8.PNG),![ppt9](https://assets.leetcode-cn.com/solution-static/269/9.PNG),![ppt10](https://assets.leetcode-cn.com/solution-static/269/10.PNG)>

```Python [sol1-Python3]
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        g = {}
        for c in words[0]:
            g[c] = []
        for s, t in pairwise(words):
            for c in t:
                g.setdefault(c, [])
            for u, v in zip(s, t):
                if u != v:
                    g[u].append(v)
                    break
            else:
                if len(s) > len(t):
                    return ""

        VISITING, VISITED = 1, 2
        states = {}
        order = []
        def dfs(u: str) -> bool:
            states[u] = VISITING
            for v in g[u]:
                if v not in states:
                    if not dfs(v):
                        return False
                elif states[v] == VISITING:
                    return False
            order.append(u)
            states[u] = VISITED
            return True

        return ''.join(reversed(order)) if all(dfs(u) for u in g if u not in states) else ""
```

```Java [sol1-Java]
class Solution {
    static final int VISITING = 1, VISITED = 2;
    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();
    Map<Character, Integer> states = new HashMap<Character, Integer>();
    boolean valid = true;
    char[] order;
    int index;

    public String alienOrder(String[] words) {
        int length = words.length;
        for (String word : words) {
            int wordLength = word.length();
            for (int j = 0; j < wordLength; j++) {
                char c = word.charAt(j);
                edges.putIfAbsent(c, new ArrayList<Character>());
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        order = new char[edges.size()];
        index = edges.size() - 1;
        Set<Character> letterSet = edges.keySet();
        for (char u : letterSet) {
            if (!states.containsKey(u)) {
                dfs(u);
            }
        }
        if (!valid) {
            return "";
        }
        return new String(order);
    }

    public void addEdge(String before, String after) {
        int length1 = before.length(), length2 = after.length();
        int length = Math.min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before.charAt(index), c2 = after.charAt(index);
            if (c1 != c2) {
                edges.get(c1).add(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    public void dfs(char u) {
        states.put(u, VISITING);
        List<Character> adjacent = edges.get(u);
        for (char v : adjacent) {
            if (!states.containsKey(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states.get(v) == VISITING) {
                valid = false;
                return;
            }
        }
        states.put(u, VISITED);
        order[index] = u;
        index--;
    }
}
```

```C# [sol1-C#]
public class Solution {
    const int VISITING = 1, VISITED = 2;
    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();
    Dictionary<char, int> states = new Dictionary<char, int>();
    bool valid = true;
    char[] order;
    int index;

    public string AlienOrder(string[] words) {
        int length = words.Length;
        foreach (string word in words) {
            foreach (char c in word) {
                if (!edges.ContainsKey(c)) {
                    edges.Add(c, new List<char>());
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            AddEdge(words[i - 1], words[i]);
        }
        order = new char[edges.Count];
        index = edges.Count - 1;
        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;
        foreach (char u in letterSet) {
            if (!states.ContainsKey(u)) {
                DFS(u);
            }
        }
        if (!valid) {
            return "";
        }
        return new string(order);
    }

    public void AddEdge(string before, string after) {
        int length1 = before.Length, length2 = after.Length;
        int length = Math.Min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].Add(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    public void DFS(char u) {
        states.Add(u, VISITING);
        IList<char> adjacent = edges[u];
        foreach (char v in adjacent) {
            if (!states.ContainsKey(v)) {
                DFS(v);
                if (!valid) {
                    return;
                }
            } else if (states[v] == VISITING) {
                valid = false;
                return;
            }
        }
        states[u] = VISITED;
        order[index] = u;
        index--;
    }
}
```

```C++ [sol1-C++]
class Solution {
public:
    const int VISITING = 1, VISITED = 2;
    unordered_map<char, vector<char>> edges;
    unordered_map<char, int> states;
    bool valid = true;
    string order;
    int index;

    string alienOrder(vector<string>& words) {
        int length = words.size();
        for (string & word : words) {
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                char c = word[j];
                if (!edges.count(c)) {
                    edges[c] = vector<char>();
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        order = string(edges.size(), ' ');
        index = edges.size() - 1;
        for (auto [u, _] : edges) {
            if (!states.count(u)) {
                dfs(u);
            }
        }
        if (!valid) {
            return "";
        }
        return order;
    }

    void addEdge(string before, string after) {
        int length1 = before.size(), length2 = after.size();
        int length = min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].emplace_back(c2);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }

    void dfs(char u) {
        states[u] = VISITING;
        for (char v : edges[u]) {
            if (!states.count(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states[v] == VISITING) {
                valid = false;
                return;
            }
        }
        states[u] = VISITED;
        order[index] = u;
        index--;
    }
};
```

```C [sol1-C]
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define VISITING 1
#define VISITED 2

void addEdge(const char *before, const char *after, int **edges, bool *valid) {
    int length1 = strlen(before), length2 = strlen(after);
    int length = MIN(length1, length2);
    int index = 0;
    while (index < length) {
        char c1 = before[index], c2 = after[index];
        if (c1 != c2) {
            edges[c1 - 'a'][c2 - 'a'] = 1;
            break;
        }
        index++;
    }
    if (index == length && length1 > length2) {
        *valid = false;
    }
}

void dfs(int u, char *order, int *index, int **edges, int *states, bool *valid) {
    states[u] = VISITING;
    if (edges[u]) {
        for (int i = 0; i < 26; i++) {
            if (edges[u][i]) {
                if (!states[i]) {
                    dfs(i, order, index, edges, states, valid);
                    if (!valid) {
                        return;
                    }
                } else if (states[i] == VISITING) {
                    *valid = false;
                    return;
                }
            }
        }
    }
    states[u] = VISITED;
    order[*index] = 'a' + u;
    (*index)--;
}

char * alienOrder(char ** words, int wordsSize) {
    int edgesSize = 0;
    int *edges[26];
    int states[26];
    bool valid = true;
    for (int i = 0; i < 26; i++) {
        edges[i] = NULL;
    }
    memset(states, 0, sizeof(states));
    for (int i = 0; i < wordsSize; i++) {
        int wordLength = strlen(words[i]);
        for (int j = 0; j < wordLength; j++) {
            char c = words[i][j];
            if (!edges[c - 'a']) {
                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);
                memset(edges[c - 'a'], 0, sizeof(int) * 26);
                edgesSize++;
            }
        }
    }
    for (int i = 1; i < wordsSize && valid; i++) {
        addEdge(words[i - 1], words[i], edges, &valid);
    }
    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));
    memset(order, ' ', sizeof(char) * edgesSize);
    order[edgesSize] = '\0';
    int index = edgesSize - 1;
    for (int i = 0; i < 26; i++) {
        if (edges[i] && !states[i]) {
            dfs(i, order, &index, edges, states, &valid);
        }
    }
    for (int i = 0; i < 26; i++) {
        if (edges[i]) {
            free(edges[i]);
        }
    }
    if (!valid) {
        order[0] = '\0';
    }
    return order;
}
```

```JavaScript [sol1-JavaScript]
var alienOrder = function(words) {
    const VISITING = 1, VISITED = 2;
    let valid = true;
    const edges = new Map();
    const states = new Map();
    const length = words.length;
    for (const word of words) {
        const wordLength = word.length;
        for (let j = 0; j < wordLength; j++) {
            const c = word[j];
            if (!edges.has(c)) {
                edges.set(c, []);
            }
        }
    }

    const addEdge = (before, after) => {
        const length1 = before.length, length2 = after.length;
        const length = Math.min(length1, length2);
        let index = 0;
        while (index < length) {
            const c1 = before[index], c2 = after[index];
            if (c1 !== c2) {
                edges.get(c1).push(c2);
                break;
            }
            index++;
        }
        if (index === length && length1 > length2) {
            valid = false;
        }
    }

    const dfs = (u) => {
        states.set(u, VISITING);
        const adjacent = edges.get(u);
        for (const v of adjacent) {
            if (!states.has(v)) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (states.get(v) === VISITING) {
                valid = false;
                return;
            }
        }
        states.set(u, VISITED);
        order[index] = u;
        index--;
    }

    for (let i = 1; i < length && valid; i++) {
        addEdge(words[i - 1], words[i]);
    }
    const order = new Array(edges.size).fill(0);
    let index = edges.size - 1;
    const letterSet = edges.keys();
    for (const u of letterSet) {
        if (!states.has(u)) {
            dfs(u);
        }
    }
    if (!valid) {
        return "";
    }
    return order.join('');

    
};
```

```go [sol1-Golang]
func alienOrder(words []string) string {
    g := map[byte][]byte{}
    for _, c := range words[0] {
        g[byte(c)] = nil
    }
next:
    for i := 1; i < len(words); i++ {
        s, t := words[i-1], words[i]
        for _, c := range t {
            g[byte(c)] = g[byte(c)]
        }
        for j := 0; j < len(s) && j < len(t); j++ {
            if s[j] != t[j] {
                g[s[j]] = append(g[s[j]], t[j])
                continue next
            }
        }
        if len(s) > len(t) {
            return ""
        }
    }

    const visiting, visited = 1, 2
    order := make([]byte, len(g))
    i := len(g) - 1
    state := map[byte]int{}
    var dfs func(u byte) bool
    dfs = func(u byte) bool {
        state[u] = visiting
        for _, v := range g[u] {
            if state[v] == 0 {
                if !dfs(v) {
                    return false
                }
            } else if state[v] == visiting {
                return false
            }
        }
        order[i] = u
        i--
        state[u] = visited
        return true
    }
    for u := range g {
        if state[u] == 0 && !dfs(u) {
            return ""
        }
    }
    return string(order)
}
```

**复杂度分析**

- 时间复杂度：$O(n \times L + |\Sigma|)$，其中 $n$ 是数组 $\textit{words}$ 的长度，即字典中的单词数，$L$ 是字典中的平均单词长度，$\Sigma$ 是字典中的字母集合。遍历字典构造有向图需要 $O(n \times L)$ 的时间，由于有向图包含最多 $n - 1$ 条边和 $|\Sigma|$ 个节点，因此深度优先搜索需要 $O(n + |\Sigma|)$ 的时间，总时间复杂度是 $O(n \times L + n + |\Sigma|) = O(n \times L + |\Sigma|)$。

- 空间复杂度：$O(n + |\Sigma|)$，其中 $n$ 是数组 $\textit{words}$ 的长度，即字典中的单词数，$\Sigma$ 是字典中的字母集合。空间复杂度主要取决于存储有向图需要的空间，有向图包含最多 $n - 1$ 条边和 $|\Sigma|$ 个节点。

#### 方法二：拓扑排序 + 广度优先搜索

方法一使用深度优先搜索实现拓扑排序，根据每个节点搜索完成的顺序反向得到拓扑排序。使用广度优先搜索实现拓扑排序，则可以正向得到拓扑排序。

首先计算每个节点的入度，只有入度为 $0$ 的节点可能是拓扑排序中最前面的节点。当一个节点加入拓扑排序之后，该节点的所有相邻节点的入度都减 $1$，表示相邻节点少了一条入边。当一个节点的入度变成 $0$，则该节点前面的节点都已经加入拓扑排序，该节点也可以加入拓扑排序。

具体做法是，使用队列存储可以加入拓扑排序的节点，初始时将所有入度为 $0$ 的节点入队列。每次将一个节点出队列并加入拓扑排序中，然后将该节点的所有相邻节点的入度都减 $1$，如果一个相邻节点的入度变成 $0$，则将该相邻节点入队列。重复上述操作，直到队列为空时，广度优先搜索结束。

如果有向图中无环，则每个节点都将加入拓扑排序，因此拓扑排序的长度等于字典中的字母个数。如果有向图中有环，则环中的节点不会加入拓扑排序，因此拓扑排序的长度小于字典中的字母个数。广度优先搜索结束时，判断拓扑排序的长度是否等于字典中的字母个数，即可判断有向图中是否有环。

- 如果拓扑排序的长度等于字典中的字母个数，则拓扑排序包含字典中的所有字母，返回拓扑排序；

- 如果拓扑排序的长度小于字典中的字母个数，则有向图中有环，不存在拓扑排序。

<![p1](https://assets.leetcode-cn.com/solution-static/269/p1.PNG),![p2](https://assets.leetcode-cn.com/solution-static/269/p2.PNG),![p3](https://assets.leetcode-cn.com/solution-static/269/p3.PNG),![p4](https://assets.leetcode-cn.com/solution-static/269/p4.PNG),![p5](https://assets.leetcode-cn.com/solution-static/269/p5.PNG),![p6](https://assets.leetcode-cn.com/solution-static/269/p6.PNG),![p7](https://assets.leetcode-cn.com/solution-static/269/p7.PNG),![p8](https://assets.leetcode-cn.com/solution-static/269/p8.PNG),![p9](https://assets.leetcode-cn.com/solution-static/269/p9.PNG),![p10](https://assets.leetcode-cn.com/solution-static/269/p10.PNG),![p11](https://assets.leetcode-cn.com/solution-static/269/p11.PNG),![p12](https://assets.leetcode-cn.com/solution-static/269/p12.PNG)>

```Python [sol2-Python3]
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        g = defaultdict(list)
        inDeg = {c: 0 for c in words[0]}
        for s, t in pairwise(words):
            for c in t:
                inDeg.setdefault(c, 0)
            for u, v in zip(s, t):
                if u != v:
                    g[u].append(v)
                    inDeg[v] += 1
                    break
            else:
                if len(s) > len(t):
                    return ""

        q = [u for u, d in inDeg.items() if d == 0]
        for u in q:
            for v in g[u]:
                inDeg[v] -= 1
                if inDeg[v] == 0:
                    q.append(v)
        return ''.join(q) if len(q) == len(inDeg) else ""
```

```Java [sol2-Java]
class Solution {
    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();
    Map<Character, Integer> indegrees = new HashMap<Character, Integer>();
    boolean valid = true;

    public String alienOrder(String[] words) {
        int length = words.length;
        for (String word : words) {
            int wordLength = word.length();
            for (int j = 0; j < wordLength; j++) {
                char c = word.charAt(j);
                edges.putIfAbsent(c, new ArrayList<Character>());
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        Queue<Character> queue = new ArrayDeque<Character>();
        Set<Character> letterSet = edges.keySet();
        for (char u : letterSet) {
            if (!indegrees.containsKey(u)) {
                queue.offer(u);
            }
        }
        StringBuffer order = new StringBuffer();
        while (!queue.isEmpty()) {
            char u = queue.poll();
            order.append(u);
            List<Character> adjacent = edges.get(u);
            for (char v : adjacent) {
                indegrees.put(v, indegrees.get(v) - 1);
                if (indegrees.get(v) == 0) {
                    queue.offer(v);
                }
            }
        }
        return order.length() == edges.size() ? order.toString() : "";
    }

    public void addEdge(String before, String after) {
        int length1 = before.length(), length2 = after.length();
        int length = Math.min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before.charAt(index), c2 = after.charAt(index);
            if (c1 != c2) {
                edges.get(c1).add(c2);
                indegrees.put(c2, indegrees.getOrDefault(c2, 0) + 1);
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
}
```

```C# [sol2-C#]
public class Solution {
    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();
    Dictionary<char, int> indegrees = new Dictionary<char, int>();
    bool valid = true;

    public string AlienOrder(string[] words) {
        int length = words.Length;
        foreach (string word in words) {
            foreach (char c in word) {
                if (!edges.ContainsKey(c)) {
                    edges.Add(c, new List<char>());
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            AddEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        Queue<char> queue = new Queue<char>();
        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;
        foreach (char u in letterSet) {
            if (!indegrees.ContainsKey(u)) {
                queue.Enqueue(u);
            }
        }
        StringBuilder order = new StringBuilder();
        while (queue.Count > 0) {
            char u = queue.Dequeue();
            order.Append(u);
            IList<char> adjacent = edges[u];
            foreach (char v in adjacent) {
                indegrees[v]--;
                if (indegrees[v] == 0) {
                    queue.Enqueue(v);
                }
            }
        }
        return order.Length == edges.Count ? order.ToString() : "";
    }

    public void AddEdge(string before, string after) {
        int length1 = before.Length, length2 = after.Length;
        int length = Math.Min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].Add(c2);
                if (!indegrees.ContainsKey(c2)) {
                    indegrees.Add(c2, 0);
                }
                indegrees[c2]++;
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
}
```

```C++ [sol2-C++]
class Solution {
public:
    unordered_map<char, vector<char>> edges;
    unordered_map<char, int> indegrees;
    bool valid = true;

    string alienOrder(vector<string>& words) {
        int length = words.size();
        for (auto word : words) {
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                char c = word[j];
                if (!edges.count(c)) {
                    edges[c] = vector<char>();
                }
            }
        }
        for (int i = 1; i < length && valid; i++) {
            addEdge(words[i - 1], words[i]);
        }
        if (!valid) {
            return "";
        }
        queue<char> qu;
        for (auto [u, _] : edges) {
            if (!indegrees.count(u)) {
                qu.emplace(u);
            }
        }
        string order;
        while (!qu.empty()) {
            char u = qu.front();
            qu.pop();
            order.push_back(u);
            for (char v : edges[u]) {
                indegrees[v]--;
                if (indegrees[v] == 0) {
                    qu.emplace(v);
                }
            }
        }
        return order.size() == edges.size() ? order : "";
    }

    void addEdge(string before, string after) {
        int length1 = before.size(), length2 = after.size();
        int length = min(length1, length2);
        int index = 0;
        while (index < length) {
            char c1 = before[index], c2 = after[index];
            if (c1 != c2) {
                edges[c1].emplace_back(c2);
                indegrees[c2] += 1;
                break;
            }
            index++;
        }
        if (index == length && length1 > length2) {
            valid = false;
        }
    }
};
```

```C [sol2-C]
#define MIN(a, b) ((a) < (b) ? (a) : (b))

void addEdge(const char *before, const char *after, int **edges, int *indegrees, bool *valid) {
    int length1 = strlen(before), length2 = strlen(after);
    int length = MIN(length1, length2);
    int index = 0;
    while (index < length) {
        char c1 = before[index], c2 = after[index];
        if (c1 != c2 ) {
            if (edges[c1 - 'a'][c2 - 'a'] == 0) {
                edges[c1 - 'a'][c2 - 'a'] = 1;
                indegrees[c2 - 'a']++;
            }
            break;
        }
        index++;
    }
    if (index == length && length1 > length2) {
        *valid = false;
    }
}

char * alienOrder(char ** words, int wordsSize) {
    int edgesSize = 0;
    int *edges[26];
    int indegrees[26];
    bool valid = true;
    memset(indegrees, 0, sizeof(indegrees));
    for (int i = 0; i < 26; i++) {
        edges[i] = NULL;
    }
    for (int i = 0; i < wordsSize; i++) {
        int wordLength = strlen(words[i]);
        for (int j = 0; j < wordLength; j++) {
            char c = words[i][j];
            if (!edges[c - 'a']) {
                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);
                memset(edges[c - 'a'], 0, sizeof(int) * 26);
                edgesSize++;
            }
        }
    }
    for (int i = 1; i < wordsSize && valid; i++) {
        addEdge(words[i - 1], words[i], edges, indegrees, &valid);
    }
    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));
    order[edgesSize] = '\0';
    int * queue = (int *)malloc(sizeof(int) * 26);
    int head = 0;
    int tail = 0;
    int pos = 0;
    for (int i = 0; i < 26; i++) {
        if (edges[i] && !indegrees[i]) {
            queue[tail++] = i;
        }
    }
    while (head != tail) {
        int u = queue[head++];
        order[pos++] = 'a' + u;
        for (int i = 0; i < 26; i++) {
            if (edges[u][i]) {
                indegrees[i]--;
                if (indegrees[i] == 0) {
                    queue[tail++] = i;
                }
            }
        }
    }
    for (int i = 0; i < 26; i++) {
        if (edges[i]) {
            free(edges[i]);
        }
    }
    free(queue);
    if (!valid || pos != edgesSize) {
        order[0] = '\0';
    }
    return order;
}
```

```JavaScript [sol2-JavaScript]
var alienOrder = function(words) {
    let valid = true;
    const edges = new Map();
    const indegrees = new Map();
    const length = words.length;
    for (const word of words) {
        const wordLength = word.length;
        for (let j = 0; j < wordLength; j++) {
            const c = word[j];
            if (!edges.has(c)) {
                edges.set(c, []);
            }
        }
    }

    const addEdge = (before, after) => {
        const length1 = before.length, length2 = after.length;
        const length = Math.min(length1, length2);
        let index = 0;
        while (index < length) {
            const c1 = before[index], c2 = after[index];
            if (c1 !== c2) {
                edges.get(c1).push(c2);
                indegrees.set(c2, (indegrees.get(c2) || 0) + 1);
                break;
            }
            index++;
        }
        if (index === length && length1 > length2) {
            valid = false;
        }
    }

    for (let i = 1; i < length && valid; i++) {
        addEdge(words[i - 1], words[i]);
    }
    if (!valid) {
        return "";
    }
    const queue = [];
    const letterSet = edges.keys();
    for (const u of letterSet) {
        if (!indegrees.has(u)) {
            queue.push(u);
        }
    }
    const order = [];
    while (queue.length) {
        const u = queue.shift();
        order.push(u);
        const adjacent = edges.get(u);
        for (const v of adjacent) {
            indegrees.set(v, indegrees.get(v) - 1);
            if (indegrees.get(v) === 0) {
                queue.push(v);
            }
        }
    }
    return order.length === edges.size ? order.join('') : "";
};
```

```go [sol2-Golang]
func alienOrder(words []string) string {
    g := map[byte][]byte{}
    inDeg := map[byte]int{}
    for _, c := range words[0] {
        inDeg[byte(c)] = 0
    }
next:
    for i := 1; i < len(words); i++ {
        s, t := words[i-1], words[i]
        for _, c := range t {
            inDeg[byte(c)] += 0
        }
        for j := 0; j < len(s) && j < len(t); j++ {
            if s[j] != t[j] {
                g[s[j]] = append(g[s[j]], t[j])
                inDeg[t[j]]++
                continue next
            }
        }
        if len(s) > len(t) {
            return ""
        }
    }

    order := make([]byte, len(inDeg))
    q := order[:0]
    for u, d := range inDeg {
        if d == 0 {
            q = append(q, u)
        }
    }
    for len(q) > 0 {
        u := q[0]
        q = q[1:]
        for _, v := range g[u] {
            if inDeg[v]--; inDeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    if cap(q) == 0 {
        return string(order)
    }
    return ""
}
```

**复杂度分析**

- 时间复杂度：$O(n \times L + |\Sigma|)$，其中 $n$ 是数组 $\textit{words}$ 的长度，即字典中的单词数，$L$ 是字典中的平均单词长度，$\Sigma$ 是字典中的字母集合。遍历字典构造有向图需要 $O(n \times L)$ 的时间，由于有向图包含最多 $n - 1$ 条边和 $|\Sigma|$ 个节点，因此广度优先搜索需要 $O(n + |\Sigma|)$ 的时间，总时间复杂度是 $O(n \times L + n + |\Sigma|) = O(n \times L + |\Sigma|)$。

- 空间复杂度：$O(n + |\Sigma|)$，其中 $n$ 是数组 $\textit{words}$ 的长度，即字典中的单词数，$\Sigma$ 是字典中的字母集合。空间复杂度主要取决于存储有向图需要的空间，有向图包含最多 $n - 1$ 条边和 $|\Sigma|$ 个节点。
# 2.【超好理解の题目解析】难的不是拓扑排序，而是理解题意
# 提交血泪史
在3次提交失败后，我终于真正地理解了题意😶
![image.png](https://pic.leetcode-cn.com/1648952787-cXHMNK-image.png)

# 题意解析

这里我主要对题目最后列出的字典序说明进行解释。

> 字符串`s`字典顺序小于字符串`t`有两种情况：
> - 在第一个不同字母处，如果 `s` 中的字母在这门外星语言的字母顺序中位于 `t` 中字母之前，那么 `s` 的字典顺序小于 `t` 。
> - 如果前面 `min(s.length, t.length)` 字母都相同，那么 `s.length < t.length` 时，`s` 的字典顺序也小于 `t` 。

首先，**第一种情况**的意思是：
- 我们能做的事只有**排出已知的顺序**。
> 假设： `words = ["wrt","wrf","er","ett","rftt"] `
> - 对于`wrt`和`wrf`，我们只知道第一组不同的字符是`t`和`f`，根据单词的顺序，我们就能得到`t`应当排在`f`前面，即`t -> f`. **注意，这里的 w 和 r 并不存在先后关系。**
> - 同理，对于`wrf`和`er`，我们只能知道第一组不同的字符是`w`和`e`，那么只能得到`w -> e`.

**第二种情况**，举个简单例子就能明白：
> 假设：`words = ["wrt","wrtkj"] `, `s = "wrt", t = "wrtkj"`
> - `min(s.length, t.length) = s.length = 3`,也就是前3个字符都相同，那么当`s.length < t.length`的时候，单词`s`应当排在单词`t`前。

**什么情况下不合法呢？**
> 假设: `words = ["abc", "ab"]`，那么显然这两个单词的前两个字符都相同，`abc`比`ab`多了一个字符的情况下，还排在了前面，那这就违反了上面的第二种情况，所以是不合法的。

**对于未知的单词我们应该怎么办呢？**

这个例子很神奇，我看讨论区很多小伙伴都纠结在这里，我也试图用简单的语言去解释一下：
> 假设：`words = ["z", "z"]`，那么我们无法得知`z`究竟是什么顺序，索性就不用管它了，它的顺序既然无从得知，那就随便放在字典的任何一个位置都可以，**只要我们排序出来的字典中，那部分能够从`words`中得到的那部分已知信息是正确顺序就可以。**
# 代码如何设计
按照上面的分析，解题思路简单来说如下：
- 根据单词表，把已知的字符顺序确定下来，建立一个有向图，按照字典序小的指向字典序大的为方向。
- 根据建立好的图，DFS 或 BFS 进行拓扑排序，得到的结果就是已知的那部分字符的字典序。
- **得到了拓扑排序结果之后，把未知顺序的字符随意放置在排序结果中，这一步只要保证不存在重复字符即可。**   所以我们还需要统计一下单词表中所有出现过的字符。

# 本题题解
按照上面的思路，分块组织代码，完整代码在最后。

1.构建字符集
```Java []
public String alienOrder(String[] words) {
    // 1.构建字符集
    Set<Character> unknown = new HashSet<>();
    for(String word : words){
        for(int i = 0; i < word.length(); i++){
            unknown.add(word.charAt(i));
        }
    }
    // ...
}
```
2.建立有向图，使用Map结构
```Java []
public String alienOrder(String[] words) {
    // 1.构建字符集
    // ...
    
    // 2.建立有向图
    Map<Character, List<Character>> graph = new HashMap<>();
    int n = words.length;
    for(int i = 0; i < n - 1; i++){
        String w1 = words[i], w2 = words[i + 1];
        int maxLen = Math.max(w1.length(), w2.length());
        for(int j = 0; j < maxLen; j++){
            if(j == w2.length()) return "";//不合法
            if(j == w1.length()) break;

            if(w1.charAt(j) != w2.charAt(j)){
                char from = w1.charAt(j), to = w2.charAt(j);
                if(graph.get(from) == null){
                    graph.put(from, new LinkedList<>());
                }
                graph.get(from).add(to);
                break; // 只有第一个不同的字母可以确定顺序
            }
        }
    }
}
```
3.拓扑排序
```Java []
public String alienOrder(String[] words) {
    // 1.构建字符集
    // 2.建立有向图
    // 3.拓扑排序
    visited = new boolean[26];
    onPath = new boolean[26];
    path = new StringBuilder();
    for(char ch : graph.keySet()){
        traverse(graph, ch);
    }
}
boolean[] visited; // 记录结点访问情况
boolean[] onPath; // 记录路径访问情况
boolean hasCycle; // 存在环标志
StringBuilder path;// 记录排序结果

// 拓扑排序函数
void traverse(Map<Character, List<Character>> graph, char ch){
    if(onPath[ch - 'a']) hasCycle = true;//该路径曾经访问过，存在环
    if(hasCycle || visited[ch - 'a']) return; // 存在环或者已访问过该节点，直接返回

    visited[ch - 'a'] = true;
    onPath[ch - 'a'] = true;
    if(graph.get(ch) != null){
        for(char next : graph.get(ch)){
            traverse(graph, next);
        }
    }
    path.append(ch);
    onPath[ch - 'a'] = false;
}
```

4.组织最终字典序结果，把无法确定顺序的单词加入已排序的字典序列中。
```Java []
public String alienOrder(String[] words) {
    // 1.构建字符集...
    // 2.构建有向图...
    // 3.拓扑排序...

    // 4.组织最终答案
    if(hasCycle) return "";//存在环则无法排序出合法的字母顺序
    for(char unk : unknown){
        if(path.indexOf(String.valueOf(unk)) == -1){
            path.append(unk);
        }
    }
    return path.reverse().toString();
}
```

**完整代码如下：**
```Java []
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, List<Character>> graph = new HashMap<>();
        int n = words.length;
        Set<Character> unknown = new HashSet<>();
        for(String word : words){
            for(int i = 0; i < word.length(); i++){
                unknown.add(word.charAt(i));
            }
        }
        // 1. build graph
        for(int i = 0; i < n - 1; i++){
            String w1 = words[i], w2 = words[i + 1];
            int maxLen = Math.max(w1.length(), w2.length());
            for(int j = 0; j < maxLen; j++){
                if(j == w2.length()) return "";//不合法
                if(j == w1.length()) break;
                if(w1.charAt(j) != w2.charAt(j)){
                    char from = w1.charAt(j), to = w2.charAt(j);
                    if(graph.get(from) == null){
                        graph.put(from, new LinkedList<>());
                    }
                    graph.get(from).add(to);
                    break;//找到第一个不同字母，可以判断顺序
                }
            }

        }
        // 2.topological sort
        visited = new boolean[26];
        onPath = new boolean[26];
        path = new StringBuilder();
        for(char ch : graph.keySet()){
            traverse(graph, ch);
        }
        // 3. get final result
        if(hasCycle) return "";//存在环则无法排序出合法的字母顺序
        for(char unk : unknown){
            if(path.indexOf(String.valueOf(unk)) == -1){
                path.append(unk);
            }
        }
        return path.reverse().toString();

    }

    boolean[] visited;//记录结点访问
    boolean[] onPath;//记录路线访问
    boolean hasCycle;//存在环标志
    StringBuilder path;

    void traverse(Map<Character, List<Character>> graph, char ch){
        if(onPath[ch - 'a']) hasCycle = true;//该路径曾经访问过，存在环
        if(hasCycle || visited[ch - 'a']) return; // 存在环或者已访问过该节点 返回
        visited[ch - 'a'] = true;
        onPath[ch - 'a'] = true;
        if(graph.get(ch) != null){
            for(char next : graph.get(ch)){
                traverse(graph, next);
            }
        }
        path.append(ch);
        onPath[ch - 'a'] = false;
    }

}
```

欢迎在评论区讨论，有问题的地方欢迎大家指正。
# 3.【yukiyama】269 拓扑排序
# 269-火星词典

[269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) (困难)

<br />

## 解法一：拓扑排序

### 算法描述

读题后不难感觉到是个拓扑排序题，于是开始构思如何建图。显然单个字符是顶点，而边的关系蕴含在单词顺序中。先给出关于边的结论，边仅由相邻单词 $w1$ 和 $w2$ 的 **「第一对同下标相异字符」** 给出。例如根据按照词典序排放的相邻单词 $word$ 和 $world$ ，可以找到一条边，即「第一对同下标相异字符」 $d$ 和 $l$ ， $d$ 指向 $l$ （ $d$ 的字典序先于 $l$ ）。那么对于有 $n$ 个单词的 $words$ 字符串数组，因为有 $n-1$ 对相邻单词，所以最多能够构成一张具有 $n-1$ 条边的图。

**我们的目标是根据上述理解构建以字符为顶点，以字符字典序为边的图，然后输出这张图的拓扑排序结果。**  实际上我们现在还不知道哪些字符应该作为图上的顶点，比如是否要将所有出现的字符都作为顶点，还是只将决定了边的字符作为顶点。这是需要根据题意，甚至是一些测试例子来分析得到的。

<br />

#### 情形分析

现在分析一些特殊情形。

**情形一： $w1$ 是 $w2$ 的前缀。**

也就是题目描述中提到的如下:

> 如果前面 $min(s.length, t.length)$ 字母都相同，那么 $s.length < t.length$ 时，$s$ 的字典顺序也小于 $t$ 。

这种情况下 $s$ 和 $t$ 这两个单词无法确定任何一条边，但却是合法的，并且 $s$ 的字典顺序小于 $t$ 。实际例子是 `["ab","abc"]` ，将会输出 `"abc"` 。尽管没有边存在，但拓扑排序后仍会输出所有出现过的字符，这表示我们应该将 **所有字符** 都作为图的顶点。那么最终的图可能是 **不连通**  的，比如前面的例子，图由三个独立的顶点 $a,b,c$ 构成。由于入度都是 0，经过拓扑排序后会输出 `"abc"` 。这是按 **字符出现顺序** 输出的结果，因为无法确定他们之间的字典序，所以 **任意排列都是合法的输出** 。

**情形二： $w2$ 是 $w1$ 的前缀**

例如 `["abc","ab"]` ，同样无边的关系，虽然题目中没有特别强调，但按照正常的词典逻辑， **这种顺序显然是非法的** 。因此在找边建图过程中检测到这种情形，可直接返回空串。

**情形三：不属于任何边的孤立顶点**

例如 `["zx","zy"]` ，确定了一条从 $x$ 到 $y$ 的边，且图只有一条边， $z$ 是一个孤立顶点。因为该输入合法，所以输出结果要包含所有字符。实际上在情形一中也提到了，只需要将 $z$ 也作为图的顶点即可。在拓扑排序时，因为 $z$ 的入度为0，会被提前输出到结果中。根据题目要求，输出结果只需要保证 $x$ 在 $y$ 之前即可，$z$ 的位置是任意的。

**情形四：有圈图**

题目的示例三 `["z","x","z"]` 表明，当图是一个圈时，返回 **空串** 。这里想强调的是，不光是圈图非法，只要有圈就视作非法输入，需要返回空串。例如`["w","z","x","z"]` ，按照拓扑排序，结果是 `"z"` ，但因为存在圈，这个输入视作非法，**正确的结果是返回空串** 。

<br />

#### 解法总结

有了上述分析，实际上这题就是个简单题了，在找边时判断是否为情形二的非法输入，非法则直接返回空串，合法则将所有字符视作有效顶点，且初始入度为 0 。常规建图，常规拓扑排序，只是需要再做一下圈检测，图有圈则输入非法，返回空串。

虽然建图和初始化入度可以在一个方法内完成。但考虑确定边的同时，对输入进行非法检测，若非法，则无需再确定入度和建图了。并且从可读性上来说，把确定边和初始化入度分开写更好。

```markdown
1. 建图 & 初始化入度。
1.1 确定边。遍历words，根据每一对相邻单词的「第一对同下标相异字符」确定边。
1.2 上述过程会对words进行非法检测，若出现情形二的非法相邻单词，
    上述方法中会令类字段invalidInput为true。此处判断一下该字段，非法则直接返回空串。
1.3 初始化入度（也即确定顶点）。遍历words，将每一个不重复字符的入度置为0，
    其他为-1.（因此入度为0的字符即图的顶点）根据边建图。
2. 拓扑排序。排序过程中利用排序顶点数和总顶点数关系，判断是否有环。
    无环图所有顶点都将排序，故若排序数不等于顶点总数，则有环。
```

<br />

### 时空复杂度

时间复杂度：$O(n*L+∣Σ∣)$  n 是单词个数，L 是单词平均长度。构建图最多需要遍历每一个单词，时间复杂度为 $O(n*L)$ 。 $|Σ|$ 是字典中字母数，对应图中顶点数。拓扑排序时间复杂度为 $O(n + |Σ|)$。

空间复杂度：$O(n+∣Σ∣)$ ，取决于图所需的存储空间，即顶点数和边数。

<br />

### 代码

```java
class Solution {
    public String alienOrder(String[] words) {
        int n = words.length, V_NUM = 26;
        int[] indegree = new int[V_NUM]; // 入度
        Arrays.fill(indegree, -1);
        for(String word : words) { // 初始化入度，值为0表示顶点，-1表示非顶点
            char[] chs = word.toCharArray();
            for(char ch : chs) indegree[ch - 'a'] = 0;
        }
        List<List<Integer>> graph = new ArrayList<>(); // 邻接表
        for(int i = 0; i < V_NUM; i++) graph.add(new ArrayList<>());
        for(int i = 0; i < n - 1; i++){ // 构建indgree和graph
            String w1 = words[i], w2 = words[i + 1];
            char[] chs1 = w1.toCharArray(), chs2 = w2.toCharArray();
            int w1n = w1.length(), w2n = w2.length();
            int wn = w1n < w2n ? w1n : w2n, j = 0;            
            for(; j < wn; j++){
                int u = chs1[j] - 'a', v = chs2[j] - 'a'; // u > v
                if(u != v) {
                    graph.get(u).add(v);
                    indegree[v]++; 
                    break; // 一对相邻单词最多决定一条边，处理这条边后直接break
                }
            }
            if(j == wn && w1n > w2n) return ""; // word2为word1的真前缀，非法输入
        }
        return topoSort(graph, indegree);
    }
    // 拓扑排序，排序过程中判断图是否有圈
    private String topoSort(List<List<Integer>> graph, int[] indegree){
        StringBuilder sb = new StringBuilder();
        Queue<Integer> q = new ArrayDeque<>();
        int count = 0, vNum = 0; // 拓扑排序计数 & 图中总节点数
        for(int i = 0; i < indegree.length; i++){ // 将入度为0的顶点加入q中
            if(indegree[i] != -1) {
                vNum++; // 存在
                if(indegree[i] == 0){ // 存在且入度为0
                    q.add(i);
                    sb.append((char) (i + 'a')); // 入度为0的顶点先输出
                    count++; // 排序一个计数一个
                }
            }
        }
        while(!q.isEmpty()){ // 拓扑排序
            int u = q.remove();
            for(int v : graph.get(u)){
                indegree[v]--;
                if(indegree[v] == 0){
                    q.add(v);
                    sb.append((char) (v + 'a'));
                    count++; // 排序一个计数一个
                }
            }
        }
        return count != vNum ? "" : sb.toString(); // 判断是否有圈
    }
}
```

<br />


# 4.Java 拓扑排序
**我的[leetcode解题集](https://github.com/JuiceZhou/Leetcode)，求小星星呀(๑•̀ㅂ•́)و✧**

思路：

将词典中字符串的字符两两对比，只有第一个不同的字符才是正确的排序，如`ert`和`wrf`，只能推断出`e`的优先级高于`w`，剩余字符的优先级不能推断。

将字符串的优先级构建为图，然后进行拓扑排序。如果图中无环，则将拓扑排序输出，否则顺序是非法的。

注意对于输入`"za"`,`"zb"`,`"ca"`,`"cb"`，字符关系为`a->b、z->c`，输出可以为`azbc`、`zacb`，只要输出一种即可。


```
class Solution {
    public String alienOrder(String[] words) {
        //1.构建图
        Map<Character, Set<Character>> map = new HashMap<>();
        for (int i = 0; i < words.length - 1; i++) {
            for (int j = 0; j < words[i].length() && j < words[i + 1].length(); j++) {
                //如果字符相同，比较下一个
                if (words[i].charAt(j) == words[i + 1].charAt(j)) continue;
                //保存第一个不同的字符顺序
                Set<Character> set = map.getOrDefault(words[i].charAt(j), new HashSet<>());
                set.add(words[i + 1].charAt(j));
                map.put(words[i].charAt(j), set);
                break;
            }
        }

        //2.拓扑排序
        //创建保存入度的数组
        int[] degrees = new int[26];
        Arrays.fill(degrees, -1);
        //注意，不是26字母都在words中出现，所以出度分为两种情况：没有出现的字母出度为-1，出现了的字母的出度为非负数
        for (String str : words) {
            //将出现过的字符的出度设定为0
            for (char c : str.toCharArray())
                degrees[c - 'a'] = 0;
        }
        for (char key : map.keySet()) {
            for (char val : map.get(key)) {
                degrees[val - 'a']++;
            }
        }
        //创建StringBuilder保存拓扑排序
        StringBuilder sb = new StringBuilder();
        //创建一个Queue保存入度为0的节点
        Queue<Character> list = new LinkedList<>();

        int count = 0;//计算图中节点数
        for (int i = 0; i < 26; i++) {
            if (degrees[i] != -1) count++;
            if (degrees[i] == 0) {
                list.add((char) ('a' + i));
            }
        }

        while (!list.isEmpty()) {
            Character cur = list.poll();
            sb.append(cur);
            //将邻接点出度-1
            if (map.containsKey(cur)) {
                Set<Character> set = map.get(cur);
                for (Character c : set) {
                    degrees[c - 'a']--;
                    if (degrees[c - 'a'] == 0) list.add(c);
                }
            }
        }

        //判断是否有环
        if (sb.length() != count) return "";
        else return sb.toString();

    }
}
```

